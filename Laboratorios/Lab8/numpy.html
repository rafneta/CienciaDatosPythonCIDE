
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NumPy &#8212; Introducción a la ciencia de datos</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.37f24b989f4638ff9c27c22dc7559d4f.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/estilo.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/.ipynb_checkpoints/estilo-checkpoint.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/estilo.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/.ipynb_checkpoints/estilo-checkpoint.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="../../_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="Pandas" href="Pandas.html" />
    <link rel="prev" title="Laboratorio 8" href="lab8.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/logo.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Introducción a la ciencia de datos</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Buscar este libro ..." aria-label="Buscar este libro ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Sobre este sitio
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Información del curso
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../docs/encuadre.html">
   Encuadre
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../docs/calendarioLab.html">
   Calendario Laboratorio
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../docs/Navegacion.html">
   Navegación en el libro
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../docs/Pizarron.html">
   Pizarrón
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Clases
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../Clases/1_intro.html">
   1. Introducción a Python
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Laboratorios
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab1/lab1.html">
   1. Anaconda, GitHub
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab1/instalacion.html">
     Instalación Anaconda
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab1/GitHub.html">
     Introducción a GitHub
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab2/lab2.html">
   2. Datos, flujo, funciones
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab2/Varfunif.html">
     Variables y Condiciones
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab2/fundamentos.html">
     Operaciones con tipos de datos básicos
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab2/Introfunmod.html">
     Introducción a funciones y módulos
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab3/lab3.html">
   3. Funciones, Métodos, Ciclos
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab3/FuncionesMetodos.html">
     Funciones y métodos
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab3/ListasyCiclos.html">
     Listas y Ciclos
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab4/lab4.html">
   4. Ciclos, Excepciones
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab4/Ciclos.html">
     Ciclos
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab4/Excepciones.html">
     Control de Excepciones
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab5/lab5.html">
   5. Paradigmas, lambda, recursión
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab5/ModulosEjemplos.html">
     Comprensión, lambdas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab5/Recursion.html">
     Recursión
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab6/lab6.html">
   6. Árboles (clasificación), Estructuras
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab6/Arboles.html">
     Arboles de Decisiones
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab6/Estructuras.html">
     Estructuras
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Lab7/lab7.html">
   7. Repaso
  </a>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="lab8.html">
   8. Numpy y Pandas
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="#ejemplo-econometria">
     Ejemplo Econometría
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="Pandas.html">
     Pandas
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab9/lab9.html">
   9. Numpy II y Pandas II
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab9/numpy2.html">
     NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab9/PandasI.html">
     Pandas
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab10/lab10.html">
   10. Ejemplos Numpy y pandas
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab10/PandasII.html">
     Pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab10/EjemploPandas.html">
     Ejemplos Pandas
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab11/lab11.html">
   11. AED, Exp. Reg., Scraping
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab11/EDA.html">
     EDA
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab11/ExpresionesRegulares.html">
     Cadenas, Expresiones regulares
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab11/ExpresionesRegulares.html#expresiones-regulares">
     Expresiones regulares
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab11/Scraping.html">
     Scraping, HTML
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../Lab12/lab12.html">
   12. Widgets, Visualización
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab12/Widgets.html">
     ipywidgets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab12/Widgets.html#numeros-complejos-y-el-plano-complejo">
     1. Números complejos y el plano complejo
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Lab12/Tableros.html">
     Tableros
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Tareas
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../Tareas/1_intro_tarea.html">
   Tarea 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../Tareas/tarea2.html">
   Tarea 2
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../Tareas/soluciones.html">
   Soluciones
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Proyecto
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../docs/Proyecto.html">
   Proyecto
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Navegación de palanca" aria-controls="site-navigation"
                title="Navegación de palanca" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Descarga esta pagina"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/Laboratorios/Lab8/numpy.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Descargar archivo fuente" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Imprimir en PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/rafneta/CienciaDatosPythonCIDE"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Repositorio de origen"><i
                    class="fab fa-github"></i>repositorio</button></a>
        <a class="issues-button"
            href="https://github.com/rafneta/CienciaDatosPythonCIDE/issues/new?title=Issue%20on%20page%20%2FLaboratorios/Lab8/numpy.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Abrir un problema"><i class="fas fa-lightbulb"></i>Tema abierto</button></a>
        
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Modo de pantalla completa"
                    title="Modo de pantalla completa"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/rafneta/CienciaDatosPythonCIDE/master?urlpath=tree/Laboratorios/Lab8/numpy.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Lanzamiento Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/rafneta/CienciaDatosPythonCIDE/blob/master/Laboratorios/Lab8/numpy.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Lanzamiento Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Lanzamiento Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contenido
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   NumPy
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#arreglos">
     Arreglos
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ejemplo-econometria">
   Ejemplo Econometría
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#regresion-simple">
     Regresión Simple
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#wooldridge-2016-ejemplo-2-3">
       Wooldridge 2016, ejemplo-2-3
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#modulo-statsmodels">
       Módulo statsmodels
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#guardamos-las-regresiones">
       Guardamos las regresiones
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <p><img alt="" src="https://raw.githubusercontent.com/rafneta/CienciaDatosPythonCIDE/master/imagenes/banner.png" /></p>
<div class="section" id="numpy">
<h1>NumPy<a class="headerlink" href="#numpy" title="Enlazar permanentemente con este título">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="https://numpy.org/">Página principal de NumPy</a></p></li>
<li><p><a class="reference external" href="https://numpy.org/doc/stable/">Documentación</a></p></li>
</ul>
<p><img alt="Image" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-020-2649-2/MediaObjects/41586_2020_2649_Fig2_HTML.png?as=webp" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;ALLOW_THREADS&#39;,
 &#39;AxisError&#39;,
 &#39;BUFSIZE&#39;,
 &#39;CLIP&#39;,
 &#39;ComplexWarning&#39;,
 &#39;DataSource&#39;,
 &#39;ERR_CALL&#39;,
 &#39;ERR_DEFAULT&#39;,
 &#39;ERR_IGNORE&#39;,
 &#39;ERR_LOG&#39;,
 &#39;ERR_PRINT&#39;,
 &#39;ERR_RAISE&#39;,
 &#39;ERR_WARN&#39;,
 &#39;FLOATING_POINT_SUPPORT&#39;,
 &#39;FPE_DIVIDEBYZERO&#39;,
 &#39;FPE_INVALID&#39;,
 &#39;FPE_OVERFLOW&#39;,
 &#39;FPE_UNDERFLOW&#39;,
 &#39;False_&#39;,
 &#39;Inf&#39;,
 &#39;Infinity&#39;,
 &#39;MAXDIMS&#39;,
 &#39;MAY_SHARE_BOUNDS&#39;,
 &#39;MAY_SHARE_EXACT&#39;,
 &#39;MachAr&#39;,
 &#39;ModuleDeprecationWarning&#39;,
 &#39;NAN&#39;,
 &#39;NINF&#39;,
 &#39;NZERO&#39;,
 &#39;NaN&#39;,
 &#39;PINF&#39;,
 &#39;PZERO&#39;,
 &#39;RAISE&#39;,
 &#39;RankWarning&#39;,
 &#39;SHIFT_DIVIDEBYZERO&#39;,
 &#39;SHIFT_INVALID&#39;,
 &#39;SHIFT_OVERFLOW&#39;,
 &#39;SHIFT_UNDERFLOW&#39;,
 &#39;ScalarType&#39;,
 &#39;Tester&#39;,
 &#39;TooHardError&#39;,
 &#39;True_&#39;,
 &#39;UFUNC_BUFSIZE_DEFAULT&#39;,
 &#39;UFUNC_PYVALS_NAME&#39;,
 &#39;VisibleDeprecationWarning&#39;,
 &#39;WRAP&#39;,
 &#39;_NoValue&#39;,
 &#39;_UFUNC_API&#39;,
 &#39;__NUMPY_SETUP__&#39;,
 &#39;__all__&#39;,
 &#39;__builtins__&#39;,
 &#39;__cached__&#39;,
 &#39;__config__&#39;,
 &#39;__dir__&#39;,
 &#39;__doc__&#39;,
 &#39;__file__&#39;,
 &#39;__getattr__&#39;,
 &#39;__git_revision__&#39;,
 &#39;__loader__&#39;,
 &#39;__mkl_version__&#39;,
 &#39;__name__&#39;,
 &#39;__package__&#39;,
 &#39;__path__&#39;,
 &#39;__spec__&#39;,
 &#39;__version__&#39;,
 &#39;_add_newdoc_ufunc&#39;,
 &#39;_distributor_init&#39;,
 &#39;_globals&#39;,
 &#39;_mat&#39;,
 &#39;_pytesttester&#39;,
 &#39;abs&#39;,
 &#39;absolute&#39;,
 &#39;add&#39;,
 &#39;add_docstring&#39;,
 &#39;add_newdoc&#39;,
 &#39;add_newdoc_ufunc&#39;,
 &#39;alen&#39;,
 &#39;all&#39;,
 &#39;allclose&#39;,
 &#39;alltrue&#39;,
 &#39;amax&#39;,
 &#39;amin&#39;,
 &#39;angle&#39;,
 &#39;any&#39;,
 &#39;append&#39;,
 &#39;apply_along_axis&#39;,
 &#39;apply_over_axes&#39;,
 &#39;arange&#39;,
 &#39;arccos&#39;,
 &#39;arccosh&#39;,
 &#39;arcsin&#39;,
 &#39;arcsinh&#39;,
 &#39;arctan&#39;,
 &#39;arctan2&#39;,
 &#39;arctanh&#39;,
 &#39;argmax&#39;,
 &#39;argmin&#39;,
 &#39;argpartition&#39;,
 &#39;argsort&#39;,
 &#39;argwhere&#39;,
 &#39;around&#39;,
 &#39;array&#39;,
 &#39;array2string&#39;,
 &#39;array_equal&#39;,
 &#39;array_equiv&#39;,
 &#39;array_repr&#39;,
 &#39;array_split&#39;,
 &#39;array_str&#39;,
 &#39;asanyarray&#39;,
 &#39;asarray&#39;,
 &#39;asarray_chkfinite&#39;,
 &#39;ascontiguousarray&#39;,
 &#39;asfarray&#39;,
 &#39;asfortranarray&#39;,
 &#39;asmatrix&#39;,
 &#39;asscalar&#39;,
 &#39;atleast_1d&#39;,
 &#39;atleast_2d&#39;,
 &#39;atleast_3d&#39;,
 &#39;average&#39;,
 &#39;bartlett&#39;,
 &#39;base_repr&#39;,
 &#39;binary_repr&#39;,
 &#39;bincount&#39;,
 &#39;bitwise_and&#39;,
 &#39;bitwise_not&#39;,
 &#39;bitwise_or&#39;,
 &#39;bitwise_xor&#39;,
 &#39;blackman&#39;,
 &#39;block&#39;,
 &#39;bmat&#39;,
 &#39;bool&#39;,
 &#39;bool8&#39;,
 &#39;bool_&#39;,
 &#39;broadcast&#39;,
 &#39;broadcast_arrays&#39;,
 &#39;broadcast_to&#39;,
 &#39;busday_count&#39;,
 &#39;busday_offset&#39;,
 &#39;busdaycalendar&#39;,
 &#39;byte&#39;,
 &#39;byte_bounds&#39;,
 &#39;bytes0&#39;,
 &#39;bytes_&#39;,
 &#39;c_&#39;,
 &#39;can_cast&#39;,
 &#39;cast&#39;,
 &#39;cbrt&#39;,
 &#39;cdouble&#39;,
 &#39;ceil&#39;,
 &#39;cfloat&#39;,
 &#39;char&#39;,
 &#39;character&#39;,
 &#39;chararray&#39;,
 &#39;choose&#39;,
 &#39;clip&#39;,
 &#39;clongdouble&#39;,
 &#39;clongfloat&#39;,
 &#39;column_stack&#39;,
 &#39;common_type&#39;,
 &#39;compare_chararrays&#39;,
 &#39;compat&#39;,
 &#39;complex&#39;,
 &#39;complex128&#39;,
 &#39;complex256&#39;,
 &#39;complex64&#39;,
 &#39;complex_&#39;,
 &#39;complexfloating&#39;,
 &#39;compress&#39;,
 &#39;concatenate&#39;,
 &#39;conj&#39;,
 &#39;conjugate&#39;,
 &#39;convolve&#39;,
 &#39;copy&#39;,
 &#39;copysign&#39;,
 &#39;copyto&#39;,
 &#39;core&#39;,
 &#39;corrcoef&#39;,
 &#39;correlate&#39;,
 &#39;cos&#39;,
 &#39;cosh&#39;,
 &#39;count_nonzero&#39;,
 &#39;cov&#39;,
 &#39;cross&#39;,
 &#39;csingle&#39;,
 &#39;ctypeslib&#39;,
 &#39;cumprod&#39;,
 &#39;cumproduct&#39;,
 &#39;cumsum&#39;,
 &#39;datetime64&#39;,
 &#39;datetime_as_string&#39;,
 &#39;datetime_data&#39;,
 &#39;deg2rad&#39;,
 &#39;degrees&#39;,
 &#39;delete&#39;,
 &#39;deprecate&#39;,
 &#39;deprecate_with_doc&#39;,
 &#39;diag&#39;,
 &#39;diag_indices&#39;,
 &#39;diag_indices_from&#39;,
 &#39;diagflat&#39;,
 &#39;diagonal&#39;,
 &#39;diff&#39;,
 &#39;digitize&#39;,
 &#39;disp&#39;,
 &#39;divide&#39;,
 &#39;divmod&#39;,
 &#39;dot&#39;,
 &#39;double&#39;,
 &#39;dsplit&#39;,
 &#39;dstack&#39;,
 &#39;dtype&#39;,
 &#39;e&#39;,
 &#39;ediff1d&#39;,
 &#39;einsum&#39;,
 &#39;einsum_path&#39;,
 &#39;emath&#39;,
 &#39;empty&#39;,
 &#39;empty_like&#39;,
 &#39;equal&#39;,
 &#39;error_message&#39;,
 &#39;errstate&#39;,
 &#39;euler_gamma&#39;,
 &#39;exp&#39;,
 &#39;exp2&#39;,
 &#39;expand_dims&#39;,
 &#39;expm1&#39;,
 &#39;extract&#39;,
 &#39;eye&#39;,
 &#39;fabs&#39;,
 &#39;fastCopyAndTranspose&#39;,
 &#39;fft&#39;,
 &#39;fill_diagonal&#39;,
 &#39;find_common_type&#39;,
 &#39;finfo&#39;,
 &#39;fix&#39;,
 &#39;flatiter&#39;,
 &#39;flatnonzero&#39;,
 &#39;flexible&#39;,
 &#39;flip&#39;,
 &#39;fliplr&#39;,
 &#39;flipud&#39;,
 &#39;float&#39;,
 &#39;float128&#39;,
 &#39;float16&#39;,
 &#39;float32&#39;,
 &#39;float64&#39;,
 &#39;float_&#39;,
 &#39;float_power&#39;,
 &#39;floating&#39;,
 &#39;floor&#39;,
 &#39;floor_divide&#39;,
 &#39;fmax&#39;,
 &#39;fmin&#39;,
 &#39;fmod&#39;,
 &#39;format_float_positional&#39;,
 &#39;format_float_scientific&#39;,
 &#39;format_parser&#39;,
 &#39;frexp&#39;,
 &#39;frombuffer&#39;,
 &#39;fromfile&#39;,
 &#39;fromfunction&#39;,
 &#39;fromiter&#39;,
 &#39;frompyfunc&#39;,
 &#39;fromregex&#39;,
 &#39;fromstring&#39;,
 &#39;full&#39;,
 &#39;full_like&#39;,
 &#39;fv&#39;,
 &#39;gcd&#39;,
 &#39;generic&#39;,
 &#39;genfromtxt&#39;,
 &#39;geomspace&#39;,
 &#39;get_array_wrap&#39;,
 &#39;get_include&#39;,
 &#39;get_printoptions&#39;,
 &#39;getbufsize&#39;,
 &#39;geterr&#39;,
 &#39;geterrcall&#39;,
 &#39;geterrobj&#39;,
 &#39;gradient&#39;,
 &#39;greater&#39;,
 &#39;greater_equal&#39;,
 &#39;half&#39;,
 &#39;hamming&#39;,
 &#39;hanning&#39;,
 &#39;heaviside&#39;,
 &#39;histogram&#39;,
 &#39;histogram2d&#39;,
 &#39;histogram_bin_edges&#39;,
 &#39;histogramdd&#39;,
 &#39;hsplit&#39;,
 &#39;hstack&#39;,
 &#39;hypot&#39;,
 &#39;i0&#39;,
 &#39;identity&#39;,
 &#39;iinfo&#39;,
 &#39;imag&#39;,
 &#39;in1d&#39;,
 &#39;index_exp&#39;,
 &#39;indices&#39;,
 &#39;inexact&#39;,
 &#39;inf&#39;,
 &#39;info&#39;,
 &#39;infty&#39;,
 &#39;inner&#39;,
 &#39;insert&#39;,
 &#39;int&#39;,
 &#39;int0&#39;,
 &#39;int16&#39;,
 &#39;int32&#39;,
 &#39;int64&#39;,
 &#39;int8&#39;,
 &#39;int_&#39;,
 &#39;intc&#39;,
 &#39;integer&#39;,
 &#39;interp&#39;,
 &#39;intersect1d&#39;,
 &#39;intp&#39;,
 &#39;invert&#39;,
 &#39;ipmt&#39;,
 &#39;irr&#39;,
 &#39;is_busday&#39;,
 &#39;isclose&#39;,
 &#39;iscomplex&#39;,
 &#39;iscomplexobj&#39;,
 &#39;isfinite&#39;,
 &#39;isfortran&#39;,
 &#39;isin&#39;,
 &#39;isinf&#39;,
 &#39;isnan&#39;,
 &#39;isnat&#39;,
 &#39;isneginf&#39;,
 &#39;isposinf&#39;,
 &#39;isreal&#39;,
 &#39;isrealobj&#39;,
 &#39;isscalar&#39;,
 &#39;issctype&#39;,
 &#39;issubclass_&#39;,
 &#39;issubdtype&#39;,
 &#39;issubsctype&#39;,
 &#39;iterable&#39;,
 &#39;ix_&#39;,
 &#39;kaiser&#39;,
 &#39;kron&#39;,
 &#39;lcm&#39;,
 &#39;ldexp&#39;,
 &#39;left_shift&#39;,
 &#39;less&#39;,
 &#39;less_equal&#39;,
 &#39;lexsort&#39;,
 &#39;lib&#39;,
 &#39;linalg&#39;,
 &#39;linspace&#39;,
 &#39;little_endian&#39;,
 &#39;load&#39;,
 &#39;loads&#39;,
 &#39;loadtxt&#39;,
 &#39;log&#39;,
 &#39;log10&#39;,
 &#39;log1p&#39;,
 &#39;log2&#39;,
 &#39;logaddexp&#39;,
 &#39;logaddexp2&#39;,
 &#39;logical_and&#39;,
 &#39;logical_not&#39;,
 &#39;logical_or&#39;,
 &#39;logical_xor&#39;,
 &#39;logspace&#39;,
 &#39;long&#39;,
 &#39;longcomplex&#39;,
 &#39;longdouble&#39;,
 &#39;longfloat&#39;,
 &#39;longlong&#39;,
 &#39;lookfor&#39;,
 &#39;ma&#39;,
 &#39;mafromtxt&#39;,
 &#39;mask_indices&#39;,
 &#39;mat&#39;,
 &#39;math&#39;,
 &#39;matmul&#39;,
 &#39;matrix&#39;,
 &#39;matrixlib&#39;,
 &#39;max&#39;,
 &#39;maximum&#39;,
 &#39;maximum_sctype&#39;,
 &#39;may_share_memory&#39;,
 &#39;mean&#39;,
 &#39;median&#39;,
 &#39;memmap&#39;,
 &#39;meshgrid&#39;,
 &#39;mgrid&#39;,
 &#39;min&#39;,
 &#39;min_scalar_type&#39;,
 &#39;minimum&#39;,
 &#39;mintypecode&#39;,
 &#39;mirr&#39;,
 &#39;mkl&#39;,
 &#39;mod&#39;,
 &#39;modf&#39;,
 &#39;moveaxis&#39;,
 &#39;msort&#39;,
 &#39;multiply&#39;,
 &#39;nan&#39;,
 &#39;nan_to_num&#39;,
 &#39;nanargmax&#39;,
 &#39;nanargmin&#39;,
 &#39;nancumprod&#39;,
 &#39;nancumsum&#39;,
 &#39;nanmax&#39;,
 &#39;nanmean&#39;,
 &#39;nanmedian&#39;,
 &#39;nanmin&#39;,
 &#39;nanpercentile&#39;,
 &#39;nanprod&#39;,
 &#39;nanquantile&#39;,
 &#39;nanstd&#39;,
 &#39;nansum&#39;,
 &#39;nanvar&#39;,
 &#39;nbytes&#39;,
 &#39;ndarray&#39;,
 &#39;ndenumerate&#39;,
 &#39;ndfromtxt&#39;,
 &#39;ndim&#39;,
 &#39;ndindex&#39;,
 &#39;nditer&#39;,
 &#39;negative&#39;,
 &#39;nested_iters&#39;,
 &#39;newaxis&#39;,
 &#39;nextafter&#39;,
 &#39;nonzero&#39;,
 &#39;not_equal&#39;,
 &#39;nper&#39;,
 &#39;npv&#39;,
 &#39;numarray&#39;,
 &#39;number&#39;,
 &#39;obj2sctype&#39;,
 &#39;object&#39;,
 &#39;object0&#39;,
 &#39;object_&#39;,
 &#39;ogrid&#39;,
 &#39;oldnumeric&#39;,
 &#39;ones&#39;,
 &#39;ones_like&#39;,
 &#39;os&#39;,
 &#39;outer&#39;,
 &#39;packbits&#39;,
 &#39;pad&#39;,
 &#39;partition&#39;,
 &#39;percentile&#39;,
 &#39;pi&#39;,
 &#39;piecewise&#39;,
 &#39;place&#39;,
 &#39;pmt&#39;,
 &#39;poly&#39;,
 &#39;poly1d&#39;,
 &#39;polyadd&#39;,
 &#39;polyder&#39;,
 &#39;polydiv&#39;,
 &#39;polyfit&#39;,
 &#39;polyint&#39;,
 &#39;polymul&#39;,
 &#39;polynomial&#39;,
 &#39;polysub&#39;,
 &#39;polyval&#39;,
 &#39;positive&#39;,
 &#39;power&#39;,
 &#39;ppmt&#39;,
 &#39;printoptions&#39;,
 &#39;prod&#39;,
 &#39;product&#39;,
 &#39;promote_types&#39;,
 &#39;ptp&#39;,
 &#39;put&#39;,
 &#39;put_along_axis&#39;,
 &#39;putmask&#39;,
 &#39;pv&#39;,
 &#39;quantile&#39;,
 &#39;r_&#39;,
 &#39;rad2deg&#39;,
 &#39;radians&#39;,
 &#39;random&#39;,
 &#39;rate&#39;,
 &#39;ravel&#39;,
 &#39;ravel_multi_index&#39;,
 &#39;real&#39;,
 &#39;real_if_close&#39;,
 &#39;rec&#39;,
 &#39;recarray&#39;,
 &#39;recfromcsv&#39;,
 &#39;recfromtxt&#39;,
 &#39;reciprocal&#39;,
 &#39;record&#39;,
 &#39;remainder&#39;,
 &#39;repeat&#39;,
 &#39;require&#39;,
 &#39;reshape&#39;,
 &#39;resize&#39;,
 &#39;result_type&#39;,
 &#39;right_shift&#39;,
 &#39;rint&#39;,
 &#39;roll&#39;,
 &#39;rollaxis&#39;,
 &#39;roots&#39;,
 &#39;rot90&#39;,
 &#39;round&#39;,
 &#39;round_&#39;,
 &#39;row_stack&#39;,
 &#39;s_&#39;,
 &#39;safe_eval&#39;,
 &#39;save&#39;,
 &#39;savetxt&#39;,
 &#39;savez&#39;,
 &#39;savez_compressed&#39;,
 &#39;sctype2char&#39;,
 &#39;sctypeDict&#39;,
 &#39;sctypeNA&#39;,
 &#39;sctypes&#39;,
 &#39;searchsorted&#39;,
 &#39;select&#39;,
 &#39;set_numeric_ops&#39;,
 &#39;set_printoptions&#39;,
 &#39;set_string_function&#39;,
 &#39;setbufsize&#39;,
 &#39;setdiff1d&#39;,
 &#39;seterr&#39;,
 &#39;seterrcall&#39;,
 &#39;seterrobj&#39;,
 &#39;setxor1d&#39;,
 &#39;shape&#39;,
 &#39;shares_memory&#39;,
 &#39;short&#39;,
 &#39;show_config&#39;,
 &#39;sign&#39;,
 &#39;signbit&#39;,
 &#39;signedinteger&#39;,
 &#39;sin&#39;,
 &#39;sinc&#39;,
 &#39;single&#39;,
 &#39;singlecomplex&#39;,
 &#39;sinh&#39;,
 &#39;size&#39;,
 &#39;sometrue&#39;,
 &#39;sort&#39;,
 &#39;sort_complex&#39;,
 &#39;source&#39;,
 &#39;spacing&#39;,
 &#39;split&#39;,
 &#39;sqrt&#39;,
 &#39;square&#39;,
 &#39;squeeze&#39;,
 &#39;stack&#39;,
 &#39;std&#39;,
 &#39;str&#39;,
 &#39;str0&#39;,
 &#39;str_&#39;,
 &#39;string_&#39;,
 &#39;subtract&#39;,
 &#39;sum&#39;,
 &#39;swapaxes&#39;,
 &#39;sys&#39;,
 &#39;take&#39;,
 &#39;take_along_axis&#39;,
 &#39;tan&#39;,
 &#39;tanh&#39;,
 &#39;tensordot&#39;,
 &#39;test&#39;,
 &#39;testing&#39;,
 &#39;tile&#39;,
 &#39;timedelta64&#39;,
 &#39;trace&#39;,
 &#39;tracemalloc_domain&#39;,
 &#39;transpose&#39;,
 &#39;trapz&#39;,
 &#39;tri&#39;,
 &#39;tril&#39;,
 &#39;tril_indices&#39;,
 &#39;tril_indices_from&#39;,
 &#39;trim_zeros&#39;,
 &#39;triu&#39;,
 &#39;triu_indices&#39;,
 &#39;triu_indices_from&#39;,
 &#39;true_divide&#39;,
 &#39;trunc&#39;,
 &#39;typeDict&#39;,
 &#39;typeNA&#39;,
 &#39;typecodes&#39;,
 &#39;typename&#39;,
 &#39;ubyte&#39;,
 &#39;ufunc&#39;,
 &#39;uint&#39;,
 &#39;uint0&#39;,
 &#39;uint16&#39;,
 &#39;uint32&#39;,
 &#39;uint64&#39;,
 &#39;uint8&#39;,
 &#39;uintc&#39;,
 &#39;uintp&#39;,
 &#39;ulonglong&#39;,
 &#39;unicode&#39;,
 &#39;unicode_&#39;,
 &#39;union1d&#39;,
 &#39;unique&#39;,
 &#39;unpackbits&#39;,
 &#39;unravel_index&#39;,
 &#39;unsignedinteger&#39;,
 &#39;unwrap&#39;,
 &#39;use_hugepage&#39;,
 &#39;ushort&#39;,
 &#39;vander&#39;,
 &#39;var&#39;,
 &#39;vdot&#39;,
 &#39;vectorize&#39;,
 &#39;version&#39;,
 &#39;void&#39;,
 &#39;void0&#39;,
 &#39;vsplit&#39;,
 &#39;vstack&#39;,
 &#39;w&#39;,
 &#39;warnings&#39;,
 &#39;where&#39;,
 &#39;who&#39;,
 &#39;zeros&#39;,
 &#39;zeros_like&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on package numpy.linalg in numpy:

NAME
    numpy.linalg

DESCRIPTION
    ``numpy.linalg``
    ================
    
    The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient
    low level implementations of standard linear algebra algorithms. Those
    libraries may be provided by NumPy itself using C versions of a subset of their
    reference implementations but, when possible, highly optimized libraries that
    take advantage of specialized processor functionality are preferred. Examples
    of such libraries are OpenBLAS, MKL (TM), and ATLAS. Because those libraries
    are multithreaded and processor dependent, environmental variables and external
    packages such as threadpoolctl may be needed to control the number of threads
    or specify the processor architecture.
    
    - OpenBLAS: https://www.openblas.net/
    - threadpoolctl: https://github.com/joblib/threadpoolctl
    
    Please note that the most-used linear algebra functions in NumPy are present in
    the main ``numpy`` namespace rather than in ``numpy.linalg``.  There are:
    ``dot``, ``vdot``, ``inner``, ``outer``, ``matmul``, ``tensordot``, ``einsum``,
    ``einsum_path`` and ``kron``.
    
    Functions present in numpy.linalg are listed below.
    
    
    Matrix and vector products
    --------------------------
    
       multi_dot
       matrix_power
    
    Decompositions
    --------------
    
       cholesky
       qr
       svd
    
    Matrix eigenvalues
    ------------------
    
       eig
       eigh
       eigvals
       eigvalsh
    
    Norms and other numbers
    -----------------------
    
       norm
       cond
       det
       matrix_rank
       slogdet
    
    Solving equations and inverting matrices
    ----------------------------------------
    
       solve
       tensorsolve
       lstsq
       inv
       pinv
       tensorinv
    
    Exceptions
    ----------
    
       LinAlgError

PACKAGE CONTENTS
    _umath_linalg
    lapack_lite
    linalg
    setup
    tests (package)

CLASSES
    builtins.Exception(builtins.BaseException)
        LinAlgError
    
    class LinAlgError(builtins.Exception)
     |  Generic Python-exception-derived object raised by linalg functions.
     |  
     |  General purpose exception class, derived from Python&#39;s exception.Exception
     |  class, programmatically raised in linalg functions when a Linear
     |  Algebra-related condition would prevent further correct execution of the
     |  function.
     |  
     |  Parameters
     |  ----------
     |  None
     |  
     |  Examples
     |  --------
     |  &gt;&gt;&gt; from numpy import linalg as LA
     |  &gt;&gt;&gt; LA.inv(np.zeros((2,2)))
     |  Traceback (most recent call last):
     |    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
     |    File &quot;...linalg.py&quot;, line 350,
     |      in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
     |    File &quot;...linalg.py&quot;, line 249,
     |      in solve
     |      raise LinAlgError(&#39;Singular matrix&#39;)
     |  numpy.linalg.LinAlgError: Singular matrix
     |  
     |  Method resolution order:
     |      LinAlgError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    cholesky(a)
        Cholesky decomposition.
        
        Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
        where `L` is lower-triangular and .H is the conjugate transpose operator
        (which is the ordinary transpose if `a` is real-valued).  `a` must be
        Hermitian (symmetric if real-valued) and positive-definite. No
        checking is performed to verify whether `a` is Hermitian or not.
        In addition, only the lower-triangular and diagonal elements of `a`
        are used. Only `L` is actually returned.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Hermitian (symmetric if all elements are real), positive-definite
            input matrix.
        
        Returns
        -------
        L : (..., M, M) array_like
            Upper or lower-triangular Cholesky factor of `a`.  Returns a
            matrix object if `a` is a matrix object.
        
        Raises
        ------
        LinAlgError
           If the decomposition fails, for example, if `a` is not
           positive-definite.
        
        See Also
        --------
        scipy.linalg.cholesky : Similar function in SciPy.
        scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian
                                       positive-definite matrix.
        scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in
                                  `scipy.linalg.cho_solve`.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        The Cholesky decomposition is often used as a fast way of solving
        
        .. math:: A \mathbf{x} = \mathbf{b}
        
        (when `A` is both Hermitian/symmetric and positive-definite).
        
        First, we solve for :math:`\mathbf{y}` in
        
        .. math:: L \mathbf{y} = \mathbf{b},
        
        and then for :math:`\mathbf{x}` in
        
        .. math:: L.H \mathbf{x} = \mathbf{y}.
        
        Examples
        --------
        &gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])
        &gt;&gt;&gt; A
        array([[ 1.+0.j, -0.-2.j],
               [ 0.+2.j,  5.+0.j]])
        &gt;&gt;&gt; L = np.linalg.cholesky(A)
        &gt;&gt;&gt; L
        array([[1.+0.j, 0.+0.j],
               [0.+2.j, 1.+0.j]])
        &gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A
        array([[1.+0.j, 0.-2.j],
               [0.+2.j, 5.+0.j]])
        &gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
        &gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned
        array([[1.+0.j, 0.+0.j],
               [0.+2.j, 1.+0.j]])
        &gt;&gt;&gt; # But a matrix object is returned if A is a matrix object
        &gt;&gt;&gt; np.linalg.cholesky(np.matrix(A))
        matrix([[ 1.+0.j,  0.+0.j],
                [ 0.+2.j,  1.+0.j]])
    
    cond(x, p=None)
        Compute the condition number of a matrix.
        
        This function is capable of returning the condition number using
        one of seven different norms, depending on the value of `p` (see
        Parameters below).
        
        Parameters
        ----------
        x : (..., M, N) array_like
            The matrix whose condition number is sought.
        p : {None, 1, -1, 2, -2, inf, -inf, &#39;fro&#39;}, optional
            Order of the norm:
        
            =====  ============================
            p      norm for matrices
            =====  ============================
            None   2-norm, computed directly using the ``SVD``
            &#39;fro&#39;  Frobenius norm
            inf    max(sum(abs(x), axis=1))
            -inf   min(sum(abs(x), axis=1))
            1      max(sum(abs(x), axis=0))
            -1     min(sum(abs(x), axis=0))
            2      2-norm (largest sing. value)
            -2     smallest singular value
            =====  ============================
        
            inf means the numpy.inf object, and the Frobenius norm is
            the root-of-sum-of-squares norm.
        
        Returns
        -------
        c : {float, inf}
            The condition number of the matrix. May be infinite.
        
        See Also
        --------
        numpy.linalg.norm
        
        Notes
        -----
        The condition number of `x` is defined as the norm of `x` times the
        norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
        (root-of-sum-of-squares) or one of a number of other matrix norms.
        
        References
        ----------
        .. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
               Academic Press, Inc., 1980, pg. 285.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy import linalg as LA
        &gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
        &gt;&gt;&gt; a
        array([[ 1,  0, -1],
               [ 0,  1,  0],
               [ 1,  0,  1]])
        &gt;&gt;&gt; LA.cond(a)
        1.4142135623730951
        &gt;&gt;&gt; LA.cond(a, &#39;fro&#39;)
        3.1622776601683795
        &gt;&gt;&gt; LA.cond(a, np.inf)
        2.0
        &gt;&gt;&gt; LA.cond(a, -np.inf)
        1.0
        &gt;&gt;&gt; LA.cond(a, 1)
        2.0
        &gt;&gt;&gt; LA.cond(a, -1)
        1.0
        &gt;&gt;&gt; LA.cond(a, 2)
        1.4142135623730951
        &gt;&gt;&gt; LA.cond(a, -2)
        0.70710678118654746 # may vary
        &gt;&gt;&gt; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))
        0.70710678118654746 # may vary
    
    det(a)
        Compute the determinant of an array.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Input array to compute determinants for.
        
        Returns
        -------
        det : (...) array_like
            Determinant of `a`.
        
        See Also
        --------
        slogdet : Another way to represent the determinant, more suitable
          for large matrices where underflow/overflow may occur.
        scipy.linalg.det : Similar function in SciPy.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        The determinant is computed via LU factorization using the LAPACK
        routine ``z/dgetrf``.
        
        Examples
        --------
        The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:
        
        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
        &gt;&gt;&gt; np.linalg.det(a)
        -2.0 # may vary
        
        Computing determinants for a stack of matrices:
        
        &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
        &gt;&gt;&gt; a.shape
        (3, 2, 2)
        &gt;&gt;&gt; np.linalg.det(a)
        array([-2., -3., -8.])
    
    eig(a)
        Compute the eigenvalues and right eigenvectors of a square array.
        
        Parameters
        ----------
        a : (..., M, M) array
            Matrices for which the eigenvalues and right eigenvectors will
            be computed
        
        Returns
        -------
        w : (..., M) array
            The eigenvalues, each repeated according to its multiplicity.
            The eigenvalues are not necessarily ordered. The resulting
            array will be of complex type, unless the imaginary part is
            zero in which case it will be cast to a real type. When `a`
            is real the resulting eigenvalues will be real (0 imaginary
            part) or occur in conjugate pairs
        
        v : (..., M, M) array
            The normalized (unit &quot;length&quot;) eigenvectors, such that the
            column ``v[:,i]`` is the eigenvector corresponding to the
            eigenvalue ``w[i]``.
        
        Raises
        ------
        LinAlgError
            If the eigenvalue computation does not converge.
        
        See Also
        --------
        eigvals : eigenvalues of a non-symmetric array.
        eigh : eigenvalues and eigenvectors of a real symmetric or complex
               Hermitian (conjugate symmetric) array.
        eigvalsh : eigenvalues of a real symmetric or complex Hermitian
                   (conjugate symmetric) array.
        scipy.linalg.eig : Similar function in SciPy that also solves the
                           generalized eigenvalue problem.
        scipy.linalg.schur : Best choice for unitary and other non-Hermitian
                             normal matrices.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        This is implemented using the ``_geev`` LAPACK routines which compute
        the eigenvalues and eigenvectors of general square arrays.
        
        The number `w` is an eigenvalue of `a` if there exists a vector
        `v` such that ``a @ v = w * v``. Thus, the arrays `a`, `w`, and
        `v` satisfy the equations ``a @ v[:,i] = w[i] * v[:,i]``
        for :math:`i \in \{0,...,M-1\}`.
        
        The array `v` of eigenvectors may not be of maximum rank, that is, some
        of the columns may be linearly dependent, although round-off error may
        obscure that fact. If the eigenvalues are all different, then theoretically
        the eigenvectors are linearly independent and `a` can be diagonalized by
        a similarity transformation using `v`, i.e, ``inv(v) @ a @ v`` is diagonal.
        
        For non-Hermitian normal matrices the SciPy function `scipy.linalg.schur`
        is preferred because the matrix `v` is guaranteed to be unitary, which is
        not the case when using `eig`. The Schur factorization produces an
        upper triangular matrix rather than a diagonal matrix, but for normal
        matrices only the diagonal of the upper triangular matrix is needed, the
        rest is roundoff error.
        
        Finally, it is emphasized that `v` consists of the *right* (as in
        right-hand side) eigenvectors of `a`.  A vector `y` satisfying
        ``y.T @ a = z * y.T`` for some number `z` is called a *left*
        eigenvector of `a`, and, in general, the left and right eigenvectors
        of a matrix are not necessarily the (perhaps conjugate) transposes
        of each other.
        
        References
        ----------
        G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
        Academic Press, Inc., 1980, Various pp.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy import linalg as LA
        
        (Almost) trivial example with real e-values and e-vectors.
        
        &gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))
        &gt;&gt;&gt; w; v
        array([1., 2., 3.])
        array([[1., 0., 0.],
               [0., 1., 0.],
               [0., 0., 1.]])
        
        Real matrix possessing complex e-values and e-vectors; note that the
        e-values are complex conjugates of each other.
        
        &gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))
        &gt;&gt;&gt; w; v
        array([1.+1.j, 1.-1.j])
        array([[0.70710678+0.j        , 0.70710678-0.j        ],
               [0.        -0.70710678j, 0.        +0.70710678j]])
        
        Complex-valued matrix with real e-values (but complex-valued e-vectors);
        note that ``a.conj().T == a``, i.e., `a` is Hermitian.
        
        &gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])
        &gt;&gt;&gt; w, v = LA.eig(a)
        &gt;&gt;&gt; w; v
        array([2.+0.j, 0.+0.j])
        array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
               [ 0.70710678+0.j        , -0.        +0.70710678j]])
        
        Be careful about round-off error!
        
        &gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
        &gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9
        &gt;&gt;&gt; w, v = LA.eig(a)
        &gt;&gt;&gt; w; v
        array([1., 1.])
        array([[1., 0.],
               [0., 1.]])
    
    eigh(a, UPLO=&#39;L&#39;)
        Return the eigenvalues and eigenvectors of a complex Hermitian
        (conjugate symmetric) or a real symmetric matrix.
        
        Returns two objects, a 1-D array containing the eigenvalues of `a`, and
        a 2-D square array or matrix (depending on the input type) of the
        corresponding eigenvectors (in columns).
        
        Parameters
        ----------
        a : (..., M, M) array
            Hermitian or real symmetric matrices whose eigenvalues and
            eigenvectors are to be computed.
        UPLO : {&#39;L&#39;, &#39;U&#39;}, optional
            Specifies whether the calculation is done with the lower triangular
            part of `a` (&#39;L&#39;, default) or the upper triangular part (&#39;U&#39;).
            Irrespective of this value only the real parts of the diagonal will
            be considered in the computation to preserve the notion of a Hermitian
            matrix. It therefore follows that the imaginary part of the diagonal
            will always be treated as zero.
        
        Returns
        -------
        w : (..., M) ndarray
            The eigenvalues in ascending order, each repeated according to
            its multiplicity.
        v : {(..., M, M) ndarray, (..., M, M) matrix}
            The column ``v[:, i]`` is the normalized eigenvector corresponding
            to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
            a matrix object.
        
        Raises
        ------
        LinAlgError
            If the eigenvalue computation does not converge.
        
        See Also
        --------
        eigvalsh : eigenvalues of real symmetric or complex Hermitian
                   (conjugate symmetric) arrays.
        eig : eigenvalues and right eigenvectors for non-symmetric arrays.
        eigvals : eigenvalues of non-symmetric arrays.
        scipy.linalg.eigh : Similar function in SciPy (but also solves the
                            generalized eigenvalue problem).
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,
        ``_heevd``.
        
        The eigenvalues of real symmetric or complex Hermitian matrices are
        always real. [1]_ The array `v` of (column) eigenvectors is unitary
        and `a`, `w`, and `v` satisfy the equations
        ``dot(a, v[:, i]) = w[i] * v[:, i]``.
        
        References
        ----------
        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
               FL, Academic Press, Inc., 1980, pg. 222.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy import linalg as LA
        &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
        &gt;&gt;&gt; a
        array([[ 1.+0.j, -0.-2.j],
               [ 0.+2.j,  5.+0.j]])
        &gt;&gt;&gt; w, v = LA.eigh(a)
        &gt;&gt;&gt; w; v
        array([0.17157288, 5.82842712])
        array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
               [ 0.        +0.38268343j,  0.        -0.92387953j]])
        
        &gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
        array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
        &gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
        array([0.+0.j, 0.+0.j])
        
        &gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object
        &gt;&gt;&gt; A
        matrix([[ 1.+0.j, -0.-2.j],
                [ 0.+2.j,  5.+0.j]])
        &gt;&gt;&gt; w, v = LA.eigh(A)
        &gt;&gt;&gt; w; v
        array([0.17157288, 5.82842712])
        matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
                [ 0.        +0.38268343j,  0.        -0.92387953j]])
        
        &gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal
        &gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
        &gt;&gt;&gt; a
        array([[5.+2.j, 9.-2.j],
               [0.+2.j, 2.-1.j]])
        &gt;&gt;&gt; # with UPLO=&#39;L&#39; this is numerically equivalent to using LA.eig() with:
        &gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
        &gt;&gt;&gt; b
        array([[5.+0.j, 0.-2.j],
               [0.+2.j, 2.+0.j]])
        &gt;&gt;&gt; wa, va = LA.eigh(a)
        &gt;&gt;&gt; wb, vb = LA.eig(b)
        &gt;&gt;&gt; wa; wb
        array([1., 6.])
        array([6.+0.j, 1.+0.j])
        &gt;&gt;&gt; va; vb
        array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
               [ 0.        +0.89442719j,  0.        -0.4472136j ]])
        array([[ 0.89442719+0.j       , -0.        +0.4472136j],
               [-0.        +0.4472136j,  0.89442719+0.j       ]])
    
    eigvals(a)
        Compute the eigenvalues of a general matrix.
        
        Main difference between `eigvals` and `eig`: the eigenvectors aren&#39;t
        returned.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            A complex- or real-valued matrix whose eigenvalues will be computed.
        
        Returns
        -------
        w : (..., M,) ndarray
            The eigenvalues, each repeated according to its multiplicity.
            They are not necessarily ordered, nor are they necessarily
            real for real matrices.
        
        Raises
        ------
        LinAlgError
            If the eigenvalue computation does not converge.
        
        See Also
        --------
        eig : eigenvalues and right eigenvectors of general arrays
        eigvalsh : eigenvalues of real symmetric or complex Hermitian
                   (conjugate symmetric) arrays.
        eigh : eigenvalues and eigenvectors of real symmetric or complex
               Hermitian (conjugate symmetric) arrays.
        scipy.linalg.eigvals : Similar function in SciPy.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        This is implemented using the ``_geev`` LAPACK routines which compute
        the eigenvalues and eigenvectors of general square arrays.
        
        Examples
        --------
        Illustration, using the fact that the eigenvalues of a diagonal matrix
        are its diagonal elements, that multiplying a matrix on the left
        by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
        of `Q`), preserves the eigenvalues of the &quot;middle&quot; matrix.  In other words,
        if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
        ``A``:
        
        &gt;&gt;&gt; from numpy import linalg as LA
        &gt;&gt;&gt; x = np.random.random()
        &gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
        &gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
        (1.0, 1.0, 0.0)
        
        Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:
        
        &gt;&gt;&gt; D = np.diag((-1,1))
        &gt;&gt;&gt; LA.eigvals(D)
        array([-1.,  1.])
        &gt;&gt;&gt; A = np.dot(Q, D)
        &gt;&gt;&gt; A = np.dot(A, Q.T)
        &gt;&gt;&gt; LA.eigvals(A)
        array([ 1., -1.]) # random
    
    eigvalsh(a, UPLO=&#39;L&#39;)
        Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
        
        Main difference from eigh: the eigenvectors are not computed.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            A complex- or real-valued matrix whose eigenvalues are to be
            computed.
        UPLO : {&#39;L&#39;, &#39;U&#39;}, optional
            Specifies whether the calculation is done with the lower triangular
            part of `a` (&#39;L&#39;, default) or the upper triangular part (&#39;U&#39;).
            Irrespective of this value only the real parts of the diagonal will
            be considered in the computation to preserve the notion of a Hermitian
            matrix. It therefore follows that the imaginary part of the diagonal
            will always be treated as zero.
        
        Returns
        -------
        w : (..., M,) ndarray
            The eigenvalues in ascending order, each repeated according to
            its multiplicity.
        
        Raises
        ------
        LinAlgError
            If the eigenvalue computation does not converge.
        
        See Also
        --------
        eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
        eigvals : eigenvalues of general real or complex arrays.
        eig : eigenvalues and right eigenvectors of general real or complex
              arrays.
        scipy.linalg.eigvalsh : Similar function in SciPy.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy import linalg as LA
        &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
        &gt;&gt;&gt; LA.eigvalsh(a)
        array([ 0.17157288,  5.82842712]) # may vary
        
        &gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal
        &gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
        &gt;&gt;&gt; a
        array([[5.+2.j, 9.-2.j],
               [0.+2.j, 2.-1.j]])
        &gt;&gt;&gt; # with UPLO=&#39;L&#39; this is numerically equivalent to using LA.eigvals()
        &gt;&gt;&gt; # with:
        &gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
        &gt;&gt;&gt; b
        array([[5.+0.j, 0.-2.j],
               [0.+2.j, 2.+0.j]])
        &gt;&gt;&gt; wa = LA.eigvalsh(a)
        &gt;&gt;&gt; wb = LA.eigvals(b)
        &gt;&gt;&gt; wa; wb
        array([1., 6.])
        array([6.+0.j, 1.+0.j])
    
    inv(a)
        Compute the (multiplicative) inverse of a matrix.
        
        Given a square matrix `a`, return the matrix `ainv` satisfying
        ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Matrix to be inverted.
        
        Returns
        -------
        ainv : (..., M, M) ndarray or matrix
            (Multiplicative) inverse of the matrix `a`.
        
        Raises
        ------
        LinAlgError
            If `a` is not square or inversion fails.
        
        See Also
        --------
        scipy.linalg.inv : Similar function in SciPy.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy.linalg import inv
        &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
        &gt;&gt;&gt; ainv = inv(a)
        &gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))
        True
        &gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))
        True
        
        If a is a matrix object, then the return value is a matrix as well:
        
        &gt;&gt;&gt; ainv = inv(np.matrix(a))
        &gt;&gt;&gt; ainv
        matrix([[-2. ,  1. ],
                [ 1.5, -0.5]])
        
        Inverses of several matrices can be computed at once:
        
        &gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
        &gt;&gt;&gt; inv(a)
        array([[[-2.  ,  1.  ],
                [ 1.5 , -0.5 ]],
               [[-1.25,  0.75],
                [ 0.75, -0.25]]])
    
    lstsq(a, b, rcond=&#39;warn&#39;)
        Return the least-squares solution to a linear matrix equation.
        
        Computes the vector x that approximatively solves the equation
        ``a @ x = b``. The equation may be under-, well-, or over-determined
        (i.e., the number of linearly independent rows of `a` can be less than,
        equal to, or greater than its number of linearly independent columns).
        If `a` is square and of full rank, then `x` (but for round-off error)
        is the &quot;exact&quot; solution of the equation. Else, `x` minimizes the
        Euclidean 2-norm :math:`|| b - a x ||`.
        
        Parameters
        ----------
        a : (M, N) array_like
            &quot;Coefficient&quot; matrix.
        b : {(M,), (M, K)} array_like
            Ordinate or &quot;dependent variable&quot; values. If `b` is two-dimensional,
            the least-squares solution is calculated for each of the `K` columns
            of `b`.
        rcond : float, optional
            Cut-off ratio for small singular values of `a`.
            For the purposes of rank determination, singular values are treated
            as zero if they are smaller than `rcond` times the largest singular
            value of `a`.
        
            .. versionchanged:: 1.14.0
               If not set, a FutureWarning is given. The previous default
               of ``-1`` will use the machine precision as `rcond` parameter,
               the new default will use the machine precision times `max(M, N)`.
               To silence the warning and use the new default, use ``rcond=None``,
               to keep using the old behavior, use ``rcond=-1``.
        
        Returns
        -------
        x : {(N,), (N, K)} ndarray
            Least-squares solution. If `b` is two-dimensional,
            the solutions are in the `K` columns of `x`.
        residuals : {(1,), (K,), (0,)} ndarray
            Sums of residuals; squared Euclidean 2-norm for each column in
            ``b - a*x``.
            If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.
            If `b` is 1-dimensional, this is a (1,) shape array.
            Otherwise the shape is (K,).
        rank : int
            Rank of matrix `a`.
        s : (min(M, N),) ndarray
            Singular values of `a`.
        
        Raises
        ------
        LinAlgError
            If computation does not converge.
        
        See Also
        --------
        scipy.linalg.lstsq : Similar function in SciPy.
        
        Notes
        -----
        If `b` is a matrix, then all array results are returned as matrices.
        
        Examples
        --------
        Fit a line, ``y = mx + c``, through some noisy data-points:
        
        &gt;&gt;&gt; x = np.array([0, 1, 2, 3])
        &gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])
        
        By examining the coefficients, we see that the line should have a
        gradient of roughly 1 and cut the y-axis at, more or less, -1.
        
        We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
        and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:
        
        &gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T
        &gt;&gt;&gt; A
        array([[ 0.,  1.],
               [ 1.,  1.],
               [ 2.,  1.],
               [ 3.,  1.]])
        
        &gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]
        &gt;&gt;&gt; m, c
        (1.0 -0.95) # may vary
        
        Plot the data along with the fitted line:
        
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; _ = plt.plot(x, y, &#39;o&#39;, label=&#39;Original data&#39;, markersize=10)
        &gt;&gt;&gt; _ = plt.plot(x, m*x + c, &#39;r&#39;, label=&#39;Fitted line&#39;)
        &gt;&gt;&gt; _ = plt.legend()
        &gt;&gt;&gt; plt.show()
    
    matrix_power(a, n)
        Raise a square matrix to the (integer) power `n`.
        
        For positive integers `n`, the power is computed by repeated matrix
        squarings and matrix multiplications. If ``n == 0``, the identity matrix
        of the same shape as M is returned. If ``n &lt; 0``, the inverse
        is computed and then raised to the ``abs(n)``.
        
        .. note:: Stacks of object matrices are not currently supported.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Matrix to be &quot;powered&quot;.
        n : int
            The exponent can be any integer or long integer, positive,
            negative, or zero.
        
        Returns
        -------
        a**n : (..., M, M) ndarray or matrix object
            The return value is the same shape and type as `M`;
            if the exponent is positive or zero then the type of the
            elements is the same as those of `M`. If the exponent is
            negative the elements are floating-point.
        
        Raises
        ------
        LinAlgError
            For matrices that are not square or that (for negative powers) cannot
            be inverted numerically.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy.linalg import matrix_power
        &gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
        &gt;&gt;&gt; matrix_power(i, 3) # should = -i
        array([[ 0, -1],
               [ 1,  0]])
        &gt;&gt;&gt; matrix_power(i, 0)
        array([[1, 0],
               [0, 1]])
        &gt;&gt;&gt; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
        array([[ 0.,  1.],
               [-1.,  0.]])
        
        Somewhat more sophisticated example
        
        &gt;&gt;&gt; q = np.zeros((4, 4))
        &gt;&gt;&gt; q[0:2, 0:2] = -i
        &gt;&gt;&gt; q[2:4, 2:4] = i
        &gt;&gt;&gt; q # one of the three quaternion units not equal to 1
        array([[ 0., -1.,  0.,  0.],
               [ 1.,  0.,  0.,  0.],
               [ 0.,  0.,  0.,  1.],
               [ 0.,  0., -1.,  0.]])
        &gt;&gt;&gt; matrix_power(q, 2) # = -np.eye(4)
        array([[-1.,  0.,  0.,  0.],
               [ 0., -1.,  0.,  0.],
               [ 0.,  0., -1.,  0.],
               [ 0.,  0.,  0., -1.]])
    
    matrix_rank(M, tol=None, hermitian=False)
        Return matrix rank of array using SVD method
        
        Rank of the array is the number of singular values of the array that are
        greater than `tol`.
        
        .. versionchanged:: 1.14
           Can now operate on stacks of matrices
        
        Parameters
        ----------
        M : {(M,), (..., M, N)} array_like
            Input vector or stack of matrices.
        tol : (...) array_like, float, optional
            Threshold below which SVD values are considered zero. If `tol` is
            None, and ``S`` is an array with singular values for `M`, and
            ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
            set to ``S.max() * max(M.shape) * eps``.
        
            .. versionchanged:: 1.14
               Broadcasted against the stack of matrices
        hermitian : bool, optional
            If True, `M` is assumed to be Hermitian (symmetric if real-valued),
            enabling a more efficient method for finding singular values.
            Defaults to False.
        
            .. versionadded:: 1.14
        
        Returns
        -------
        rank : (...) array_like
            Rank of M.
        
        Notes
        -----
        The default threshold to detect rank deficiency is a test on the magnitude
        of the singular values of `M`.  By default, we identify singular values less
        than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
        the symbols defined above). This is the algorithm MATLAB uses [1].  It also
        appears in *Numerical recipes* in the discussion of SVD solutions for linear
        least squares [2].
        
        This default threshold is designed to detect rank deficiency accounting for
        the numerical errors of the SVD computation.  Imagine that there is a column
        in `M` that is an exact (in floating point) linear combination of other
        columns in `M`. Computing the SVD on `M` will not produce a singular value
        exactly equal to 0 in general: any difference of the smallest SVD value from
        0 will be caused by numerical imprecision in the calculation of the SVD.
        Our threshold for small SVD values takes this numerical imprecision into
        account, and the default threshold will detect such numerical rank
        deficiency.  The threshold may declare a matrix `M` rank deficient even if
        the linear combination of some columns of `M` is not exactly equal to
        another column of `M` but only numerically very close to another column of
        `M`.
        
        We chose our default threshold because it is in wide use.  Other thresholds
        are possible.  For example, elsewhere in the 2007 edition of *Numerical
        recipes* there is an alternative threshold of ``S.max() *
        np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
        this threshold as being based on &quot;expected roundoff error&quot; (p 71).
        
        The thresholds above deal with floating point roundoff error in the
        calculation of the SVD.  However, you may have more information about the
        sources of error in `M` that would make you consider other tolerance values
        to detect *effective* rank deficiency.  The most useful measure of the
        tolerance depends on the operations you intend to use on your matrix.  For
        example, if your data come from uncertain measurements with uncertainties
        greater than floating point epsilon, choosing a tolerance near that
        uncertainty may be preferable.  The tolerance may be absolute if the
        uncertainties are absolute rather than relative.
        
        References
        ----------
        .. [1] MATLAB reference documention, &quot;Rank&quot;
               https://www.mathworks.com/help/techdoc/ref/rank.html
        .. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
               &quot;Numerical Recipes (3rd edition)&quot;, Cambridge University Press, 2007,
               page 795.
        
        Examples
        --------
        &gt;&gt;&gt; from numpy.linalg import matrix_rank
        &gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix
        4
        &gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
        &gt;&gt;&gt; matrix_rank(I)
        3
        &gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
        1
        &gt;&gt;&gt; matrix_rank(np.zeros((4,)))
        0
    
    multi_dot(arrays, *, out=None)
        Compute the dot product of two or more arrays in a single function call,
        while automatically selecting the fastest evaluation order.
        
        `multi_dot` chains `numpy.dot` and uses optimal parenthesization
        of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
        this can speed up the multiplication a lot.
        
        If the first argument is 1-D it is treated as a row vector.
        If the last argument is 1-D it is treated as a column vector.
        The other arguments must be 2-D.
        
        Think of `multi_dot` as::
        
            def multi_dot(arrays): return functools.reduce(np.dot, arrays)
        
        
        Parameters
        ----------
        arrays : sequence of array_like
            If the first argument is 1-D it is treated as row vector.
            If the last argument is 1-D it is treated as column vector.
            The other arguments must be 2-D.
        out : ndarray, optional
            Output argument. This must have the exact kind that would be returned
            if it was not used. In particular, it must have the right type, must be
            C-contiguous, and its dtype must be the dtype that would be returned
            for `dot(a, b)`. This is a performance feature. Therefore, if these
            conditions are not met, an exception is raised, instead of attempting
            to be flexible.
        
            .. versionadded:: 1.19.0
        
        Returns
        -------
        output : ndarray
            Returns the dot product of the supplied arrays.
        
        See Also
        --------
        dot : dot multiplication with two arguments.
        
        References
        ----------
        
        .. [1] Cormen, &quot;Introduction to Algorithms&quot;, Chapter 15.2, p. 370-378
        .. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication
        
        Examples
        --------
        `multi_dot` allows you to write::
        
        &gt;&gt;&gt; from numpy.linalg import multi_dot
        &gt;&gt;&gt; # Prepare some data
        &gt;&gt;&gt; A = np.random.random((10000, 100))
        &gt;&gt;&gt; B = np.random.random((100, 1000))
        &gt;&gt;&gt; C = np.random.random((1000, 5))
        &gt;&gt;&gt; D = np.random.random((5, 333))
        &gt;&gt;&gt; # the actual dot multiplication
        &gt;&gt;&gt; _ = multi_dot([A, B, C, D])
        
        instead of::
        
        &gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)
        &gt;&gt;&gt; # or
        &gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)
        
        Notes
        -----
        The cost for a matrix multiplication can be calculated with the
        following function::
        
            def cost(A, B):
                return A.shape[0] * A.shape[1] * B.shape[1]
        
        Assume we have three matrices
        :math:`A_{10x100}, B_{100x5}, C_{5x50}`.
        
        The costs for the two different parenthesizations are as follows::
        
            cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
            cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
    
    norm(x, ord=None, axis=None, keepdims=False)
        Matrix or vector norm.
        
        This function is able to return one of eight different matrix norms,
        or one of an infinite number of vector norms (described below), depending
        on the value of the ``ord`` parameter.
        
        Parameters
        ----------
        x : array_like
            Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
            is None. If both `axis` and `ord` are None, the 2-norm of
            ``x.ravel`` will be returned.
        ord : {non-zero int, inf, -inf, &#39;fro&#39;, &#39;nuc&#39;}, optional
            Order of the norm (see table under ``Notes``). inf means numpy&#39;s
            `inf` object. The default is None.
        axis : {None, int, 2-tuple of ints}, optional.
            If `axis` is an integer, it specifies the axis of `x` along which to
            compute the vector norms.  If `axis` is a 2-tuple, it specifies the
            axes that hold 2-D matrices, and the matrix norms of these matrices
            are computed.  If `axis` is None then either a vector norm (when `x`
            is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
            is None.
        
            .. versionadded:: 1.8.0
        
        keepdims : bool, optional
            If this is set to True, the axes which are normed over are left in the
            result as dimensions with size one.  With this option the result will
            broadcast correctly against the original `x`.
        
            .. versionadded:: 1.10.0
        
        Returns
        -------
        n : float or ndarray
            Norm of the matrix or vector(s).
        
        See Also
        --------
        scipy.linalg.norm : Similar function in SciPy.
        
        Notes
        -----
        For values of ``ord &lt; 1``, the result is, strictly speaking, not a
        mathematical &#39;norm&#39;, but it may still be useful for various numerical
        purposes.
        
        The following norms can be calculated:
        
        =====  ============================  ==========================
        ord    norm for matrices             norm for vectors
        =====  ============================  ==========================
        None   Frobenius norm                2-norm
        &#39;fro&#39;  Frobenius norm                --
        &#39;nuc&#39;  nuclear norm                  --
        inf    max(sum(abs(x), axis=1))      max(abs(x))
        -inf   min(sum(abs(x), axis=1))      min(abs(x))
        0      --                            sum(x != 0)
        1      max(sum(abs(x), axis=0))      as below
        -1     min(sum(abs(x), axis=0))      as below
        2      2-norm (largest sing. value)  as below
        -2     smallest singular value       as below
        other  --                            sum(abs(x)**ord)**(1./ord)
        =====  ============================  ==========================
        
        The Frobenius norm is given by [1]_:
        
            :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
        
        The nuclear norm is the sum of the singular values.
        
        Both the Frobenius and nuclear norm orders are only defined for
        matrices and raise a ValueError when ``x.ndim != 2``.
        
        References
        ----------
        .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
               Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
        
        Examples
        --------
        &gt;&gt;&gt; from numpy import linalg as LA
        &gt;&gt;&gt; a = np.arange(9) - 4
        &gt;&gt;&gt; a
        array([-4, -3, -2, ...,  2,  3,  4])
        &gt;&gt;&gt; b = a.reshape((3, 3))
        &gt;&gt;&gt; b
        array([[-4, -3, -2],
               [-1,  0,  1],
               [ 2,  3,  4]])
        
        &gt;&gt;&gt; LA.norm(a)
        7.745966692414834
        &gt;&gt;&gt; LA.norm(b)
        7.745966692414834
        &gt;&gt;&gt; LA.norm(b, &#39;fro&#39;)
        7.745966692414834
        &gt;&gt;&gt; LA.norm(a, np.inf)
        4.0
        &gt;&gt;&gt; LA.norm(b, np.inf)
        9.0
        &gt;&gt;&gt; LA.norm(a, -np.inf)
        0.0
        &gt;&gt;&gt; LA.norm(b, -np.inf)
        2.0
        
        &gt;&gt;&gt; LA.norm(a, 1)
        20.0
        &gt;&gt;&gt; LA.norm(b, 1)
        7.0
        &gt;&gt;&gt; LA.norm(a, -1)
        -4.6566128774142013e-010
        &gt;&gt;&gt; LA.norm(b, -1)
        6.0
        &gt;&gt;&gt; LA.norm(a, 2)
        7.745966692414834
        &gt;&gt;&gt; LA.norm(b, 2)
        7.3484692283495345
        
        &gt;&gt;&gt; LA.norm(a, -2)
        0.0
        &gt;&gt;&gt; LA.norm(b, -2)
        1.8570331885190563e-016 # may vary
        &gt;&gt;&gt; LA.norm(a, 3)
        5.8480354764257312 # may vary
        &gt;&gt;&gt; LA.norm(a, -3)
        0.0
        
        Using the `axis` argument to compute vector norms:
        
        &gt;&gt;&gt; c = np.array([[ 1, 2, 3],
        ...               [-1, 1, 4]])
        &gt;&gt;&gt; LA.norm(c, axis=0)
        array([ 1.41421356,  2.23606798,  5.        ])
        &gt;&gt;&gt; LA.norm(c, axis=1)
        array([ 3.74165739,  4.24264069])
        &gt;&gt;&gt; LA.norm(c, ord=1, axis=1)
        array([ 6.,  6.])
        
        Using the `axis` argument to compute matrix norms:
        
        &gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)
        &gt;&gt;&gt; LA.norm(m, axis=(1,2))
        array([  3.74165739,  11.22497216])
        &gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
        (3.7416573867739413, 11.224972160321824)
    
    pinv(a, rcond=1e-15, hermitian=False)
        Compute the (Moore-Penrose) pseudo-inverse of a matrix.
        
        Calculate the generalized inverse of a matrix using its
        singular-value decomposition (SVD) and including all
        *large* singular values.
        
        .. versionchanged:: 1.14
           Can now operate on stacks of matrices
        
        Parameters
        ----------
        a : (..., M, N) array_like
            Matrix or stack of matrices to be pseudo-inverted.
        rcond : (...) array_like of float
            Cutoff for small singular values.
            Singular values less than or equal to
            ``rcond * largest_singular_value`` are set to zero.
            Broadcasts against the stack of matrices.
        hermitian : bool, optional
            If True, `a` is assumed to be Hermitian (symmetric if real-valued),
            enabling a more efficient method for finding singular values.
            Defaults to False.
        
            .. versionadded:: 1.17.0
        
        Returns
        -------
        B : (..., N, M) ndarray
            The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
            is `B`.
        
        Raises
        ------
        LinAlgError
            If the SVD computation does not converge.
        
        See Also
        --------
        scipy.linalg.pinv : Similar function in SciPy.
        scipy.linalg.pinv2 : Similar function in SciPy (SVD-based).
        scipy.linalg.pinvh : Compute the (Moore-Penrose) pseudo-inverse of a
                             Hermitian matrix.
        
        Notes
        -----
        The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
        defined as: &quot;the matrix that &#39;solves&#39; [the least-squares problem]
        :math:`Ax = b`,&quot; i.e., if :math:`\bar{x}` is said solution, then
        :math:`A^+` is that matrix such that :math:`\bar{x} = A^+b`.
        
        It can be shown that if :math:`Q_1 \Sigma Q_2^T = A` is the singular
        value decomposition of A, then
        :math:`A^+ = Q_2 \Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
        orthogonal matrices, :math:`\Sigma` is a diagonal matrix consisting
        of A&#39;s so-called singular values, (followed, typically, by
        zeros), and then :math:`\Sigma^+` is simply the diagonal matrix
        consisting of the reciprocals of A&#39;s singular values
        (again, followed by zeros). [1]_
        
        References
        ----------
        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
               FL, Academic Press, Inc., 1980, pp. 139-142.
        
        Examples
        --------
        The following example checks that ``a * a+ * a == a`` and
        ``a+ * a * a+ == a+``:
        
        &gt;&gt;&gt; a = np.random.randn(9, 6)
        &gt;&gt;&gt; B = np.linalg.pinv(a)
        &gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
        True
        &gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
        True
    
    qr(a, mode=&#39;reduced&#39;)
        Compute the qr factorization of a matrix.
        
        Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
        upper-triangular.
        
        Parameters
        ----------
        a : array_like, shape (M, N)
            Matrix to be factored.
        mode : {&#39;reduced&#39;, &#39;complete&#39;, &#39;r&#39;, &#39;raw&#39;}, optional
            If K = min(M, N), then
        
            * &#39;reduced&#39;  : returns q, r with dimensions (M, K), (K, N) (default)
            * &#39;complete&#39; : returns q, r with dimensions (M, M), (M, N)
            * &#39;r&#39;        : returns r only with dimensions (K, N)
            * &#39;raw&#39;      : returns h, tau with dimensions (N, M), (K,)
        
            The options &#39;reduced&#39;, &#39;complete, and &#39;raw&#39; are new in numpy 1.8,
            see the notes for more information. The default is &#39;reduced&#39;, and to
            maintain backward compatibility with earlier versions of numpy both
            it and the old default &#39;full&#39; can be omitted. Note that array h
            returned in &#39;raw&#39; mode is transposed for calling Fortran. The
            &#39;economic&#39; mode is deprecated.  The modes &#39;full&#39; and &#39;economic&#39; may
            be passed using only the first letter for backwards compatibility,
            but all others must be spelled out. See the Notes for more
            explanation.
        
        
        Returns
        -------
        q : ndarray of float or complex, optional
            A matrix with orthonormal columns. When mode = &#39;complete&#39; the
            result is an orthogonal/unitary matrix depending on whether or not
            a is real/complex. The determinant may be either +/- 1 in that
            case.
        r : ndarray of float or complex, optional
            The upper-triangular matrix.
        (h, tau) : ndarrays of np.double or np.cdouble, optional
            The array h contains the Householder reflectors that generate q
            along with r. The tau array contains scaling factors for the
            reflectors. In the deprecated  &#39;economic&#39; mode only h is returned.
        
        Raises
        ------
        LinAlgError
            If factoring fails.
        
        See Also
        --------
        scipy.linalg.qr : Similar function in SciPy.
        scipy.linalg.rq : Compute RQ decomposition of a matrix.
        
        Notes
        -----
        This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,
        ``dorgqr``, and ``zungqr``.
        
        For more information on the qr factorization, see for example:
        https://en.wikipedia.org/wiki/QR_factorization
        
        Subclasses of `ndarray` are preserved except for the &#39;raw&#39; mode. So if
        `a` is of type `matrix`, all the return values will be matrices too.
        
        New &#39;reduced&#39;, &#39;complete&#39;, and &#39;raw&#39; options for mode were added in
        NumPy 1.8.0 and the old option &#39;full&#39; was made an alias of &#39;reduced&#39;.  In
        addition the options &#39;full&#39; and &#39;economic&#39; were deprecated.  Because
        &#39;full&#39; was the previous default and &#39;reduced&#39; is the new default,
        backward compatibility can be maintained by letting `mode` default.
        The &#39;raw&#39; option was added so that LAPACK routines that can multiply
        arrays by q using the Householder reflectors can be used. Note that in
        this case the returned arrays are of type np.double or np.cdouble and
        the h array is transposed to be FORTRAN compatible.  No routines using
        the &#39;raw&#39; return are currently exposed by numpy, but some are available
        in lapack_lite and just await the necessary work.
        
        Examples
        --------
        &gt;&gt;&gt; a = np.random.randn(9, 6)
        &gt;&gt;&gt; q, r = np.linalg.qr(a)
        &gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr
        True
        &gt;&gt;&gt; r2 = np.linalg.qr(a, mode=&#39;r&#39;)
        &gt;&gt;&gt; np.allclose(r, r2)  # mode=&#39;r&#39; returns the same r as mode=&#39;full&#39;
        True
        
        Example illustrating a common use of `qr`: solving of least squares
        problems
        
        What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
        the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
        and you&#39;ll see that it should be y0 = 0, m = 1.)  The answer is provided
        by solving the over-determined matrix equation ``Ax = b``, where::
        
          A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
          x = array([[y0], [m]])
          b = array([[1], [0], [2], [1]])
        
        If A = qr such that q is orthonormal (which is always possible via
        Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
        however, we simply use `lstsq`.)
        
        &gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
        &gt;&gt;&gt; A
        array([[0, 1],
               [1, 1],
               [1, 1],
               [2, 1]])
        &gt;&gt;&gt; b = np.array([1, 0, 2, 1])
        &gt;&gt;&gt; q, r = np.linalg.qr(A)
        &gt;&gt;&gt; p = np.dot(q.T, b)
        &gt;&gt;&gt; np.dot(np.linalg.inv(r), p)
        array([  1.1e-16,   1.0e+00])
    
    slogdet(a)
        Compute the sign and (natural) logarithm of the determinant of an array.
        
        If an array has a very small or very large determinant, then a call to
        `det` may overflow or underflow. This routine is more robust against such
        issues, because it computes the logarithm of the determinant rather than
        the determinant itself.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Input array, has to be a square 2-D array.
        
        Returns
        -------
        sign : (...) array_like
            A number representing the sign of the determinant. For a real matrix,
            this is 1, 0, or -1. For a complex matrix, this is a complex number
            with absolute value 1 (i.e., it is on the unit circle), or else 0.
        logdet : (...) array_like
            The natural log of the absolute value of the determinant.
        
        If the determinant is zero, then `sign` will be 0 and `logdet` will be
        -Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.
        
        See Also
        --------
        det
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        .. versionadded:: 1.6.0
        
        The determinant is computed via LU factorization using the LAPACK
        routine ``z/dgetrf``.
        
        
        Examples
        --------
        The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:
        
        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
        &gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)
        &gt;&gt;&gt; (sign, logdet)
        (-1, 0.69314718055994529) # may vary
        &gt;&gt;&gt; sign * np.exp(logdet)
        -2.0
        
        Computing log-determinants for a stack of matrices:
        
        &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
        &gt;&gt;&gt; a.shape
        (3, 2, 2)
        &gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)
        &gt;&gt;&gt; (sign, logdet)
        (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
        &gt;&gt;&gt; sign * np.exp(logdet)
        array([-2., -3., -8.])
        
        This routine succeeds where ordinary `det` does not:
        
        &gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)
        0.0
        &gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)
        (1, -1151.2925464970228)
    
    solve(a, b)
        Solve a linear matrix equation, or system of linear scalar equations.
        
        Computes the &quot;exact&quot; solution, `x`, of the well-determined, i.e., full
        rank, linear matrix equation `ax = b`.
        
        Parameters
        ----------
        a : (..., M, M) array_like
            Coefficient matrix.
        b : {(..., M,), (..., M, K)}, array_like
            Ordinate or &quot;dependent variable&quot; values.
        
        Returns
        -------
        x : {(..., M,), (..., M, K)} ndarray
            Solution to the system a x = b.  Returned shape is identical to `b`.
        
        Raises
        ------
        LinAlgError
            If `a` is singular or not square.
        
        See Also
        --------
        scipy.linalg.solve : Similar function in SciPy.
        
        Notes
        -----
        
        .. versionadded:: 1.8.0
        
        Broadcasting rules apply, see the `numpy.linalg` documentation for
        details.
        
        The solutions are computed using LAPACK routine ``_gesv``.
        
        `a` must be square and of full-rank, i.e., all rows (or, equivalently,
        columns) must be linearly independent; if either is not true, use
        `lstsq` for the least-squares best &quot;solution&quot; of the
        system/equation.
        
        References
        ----------
        .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
               FL, Academic Press, Inc., 1980, pg. 22.
        
        Examples
        --------
        Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:
        
        &gt;&gt;&gt; a = np.array([[3,1], [1,2]])
        &gt;&gt;&gt; b = np.array([9,8])
        &gt;&gt;&gt; x = np.linalg.solve(a, b)
        &gt;&gt;&gt; x
        array([2.,  3.])
        
        Check that the solution is correct:
        
        &gt;&gt;&gt; np.allclose(np.dot(a, x), b)
        True
    
    svd(a, full_matrices=True, compute_uv=True, hermitian=False)
        Singular Value Decomposition.
        
        When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh
        = (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D
        array of `a`&#39;s singular values. When `a` is higher-dimensional, SVD is
        applied in stacked mode as explained below.
        
        Parameters
        ----------
        a : (..., M, N) array_like
            A real or complex array with ``a.ndim &gt;= 2``.
        full_matrices : bool, optional
            If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
            ``(..., N, N)``, respectively.  Otherwise, the shapes are
            ``(..., M, K)`` and ``(..., K, N)``, respectively, where
            ``K = min(M, N)``.
        compute_uv : bool, optional
            Whether or not to compute `u` and `vh` in addition to `s`.  True
            by default.
        hermitian : bool, optional
            If True, `a` is assumed to be Hermitian (symmetric if real-valued),
            enabling a more efficient method for finding singular values.
            Defaults to False.
        
            .. versionadded:: 1.17.0
        
        Returns
        -------
        u : { (..., M, M), (..., M, K) } array
            Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
            size as those of the input `a`. The size of the last two dimensions
            depends on the value of `full_matrices`. Only returned when
            `compute_uv` is True.
        s : (..., K) array
            Vector(s) with the singular values, within each vector sorted in
            descending order. The first ``a.ndim - 2`` dimensions have the same
            size as those of the input `a`.
        vh : { (..., N, N), (..., K, N) } array
            Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
            size as those of the input `a`. The size of the last two dimensions
            depends on the value of `full_matrices`. Only returned when
            `compute_uv` is True.
        
        Raises
        ------
        LinAlgError
            If SVD computation does not converge.
        
        See Also
        --------
        scipy.linalg.svd : Similar function in SciPy.
        scipy.linalg.svdvals : Compute singular values of a matrix.
        
        Notes
        -----
        
        .. versionchanged:: 1.8.0
           Broadcasting rules apply, see the `numpy.linalg` documentation for
           details.
        
        The decomposition is performed using LAPACK routine ``_gesdd``.
        
        SVD is usually described for the factorization of a 2D matrix :math:`A`.
        The higher-dimensional case will be discussed below. In the 2D case, SVD is
        written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
        :math:`S= \mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
        contains the singular values of `a` and `u` and `vh` are unitary. The rows
        of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
        the eigenvectors of :math:`A A^H`. In both cases the corresponding
        (possibly non-zero) eigenvalues are given by ``s**2``.
        
        If `a` has more than two dimensions, then broadcasting rules apply, as
        explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
        working in &quot;stacked&quot; mode: it iterates over all indices of the first
        ``a.ndim - 2`` dimensions and for each combination SVD is applied to the
        last two indices. The matrix `a` can be reconstructed from the
        decomposition with either ``(u * s[..., None, :]) @ vh`` or
        ``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
        function ``np.matmul`` for python versions below 3.5.)
        
        If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
        all the return values.
        
        Examples
        --------
        &gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
        &gt;&gt;&gt; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)
        
        Reconstruction based on full SVD, 2D case:
        
        &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=True)
        &gt;&gt;&gt; u.shape, s.shape, vh.shape
        ((9, 9), (6,), (6, 6))
        &gt;&gt;&gt; np.allclose(a, np.dot(u[:, :6] * s, vh))
        True
        &gt;&gt;&gt; smat = np.zeros((9, 6), dtype=complex)
        &gt;&gt;&gt; smat[:6, :6] = np.diag(s)
        &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))
        True
        
        Reconstruction based on reduced SVD, 2D case:
        
        &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=False)
        &gt;&gt;&gt; u.shape, s.shape, vh.shape
        ((9, 6), (6,), (6, 6))
        &gt;&gt;&gt; np.allclose(a, np.dot(u * s, vh))
        True
        &gt;&gt;&gt; smat = np.diag(s)
        &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))
        True
        
        Reconstruction based on full SVD, 4D case:
        
        &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=True)
        &gt;&gt;&gt; u.shape, s.shape, vh.shape
        ((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
        &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
        True
        &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
        True
        
        Reconstruction based on reduced SVD, 4D case:
        
        &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=False)
        &gt;&gt;&gt; u.shape, s.shape, vh.shape
        ((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
        &gt;&gt;&gt; np.allclose(b, np.matmul(u * s[..., None, :], vh))
        True
        &gt;&gt;&gt; np.allclose(b, np.matmul(u, s[..., None] * vh))
        True
    
    tensorinv(a, ind=2)
        Compute the &#39;inverse&#39; of an N-dimensional array.
        
        The result is an inverse for `a` relative to the tensordot operation
        ``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
        ``tensordot(tensorinv(a), a, ind)`` is the &quot;identity&quot; tensor for the
        tensordot operation.
        
        Parameters
        ----------
        a : array_like
            Tensor to &#39;invert&#39;. Its shape must be &#39;square&#39;, i. e.,
            ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
        ind : int, optional
            Number of first indices that are involved in the inverse sum.
            Must be a positive integer, default is 2.
        
        Returns
        -------
        b : ndarray
            `a`&#39;s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.
        
        Raises
        ------
        LinAlgError
            If `a` is singular or not &#39;square&#39; (in the above sense).
        
        See Also
        --------
        numpy.tensordot, tensorsolve
        
        Examples
        --------
        &gt;&gt;&gt; a = np.eye(4*6)
        &gt;&gt;&gt; a.shape = (4, 6, 8, 3)
        &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)
        &gt;&gt;&gt; ainv.shape
        (8, 3, 4, 6)
        &gt;&gt;&gt; b = np.random.randn(4, 6)
        &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
        True
        
        &gt;&gt;&gt; a = np.eye(4*6)
        &gt;&gt;&gt; a.shape = (24, 8, 3)
        &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)
        &gt;&gt;&gt; ainv.shape
        (8, 3, 24)
        &gt;&gt;&gt; b = np.random.randn(24)
        &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
        True
    
    tensorsolve(a, b, axes=None)
        Solve the tensor equation ``a x = b`` for x.
        
        It is assumed that all indices of `x` are summed over in the product,
        together with the rightmost indices of `a`, as is done in, for example,
        ``tensordot(a, x, axes=b.ndim)``.
        
        Parameters
        ----------
        a : array_like
            Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
            the shape of that sub-tensor of `a` consisting of the appropriate
            number of its rightmost indices, and must be such that
            ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
            &#39;square&#39;).
        b : array_like
            Right-hand tensor, which can be of any shape.
        axes : tuple of ints, optional
            Axes in `a` to reorder to the right, before inversion.
            If None (default), no reordering is done.
        
        Returns
        -------
        x : ndarray, shape Q
        
        Raises
        ------
        LinAlgError
            If `a` is singular or not &#39;square&#39; (in the above sense).
        
        See Also
        --------
        numpy.tensordot, tensorinv, numpy.einsum
        
        Examples
        --------
        &gt;&gt;&gt; a = np.eye(2*3*4)
        &gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)
        &gt;&gt;&gt; b = np.random.randn(2*3, 4)
        &gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)
        &gt;&gt;&gt; x.shape
        (2, 3, 4)
        &gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)
        True

DATA
    test = &lt;numpy._pytesttester.PytestTester object&gt;

FILE
    /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages/numpy/linalg/__init__.py
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function shape in module numpy:

shape(a)
    Return the shape of an array.
    
    Parameters
    ----------
    a : array_like
        Input array.
    
    Returns
    -------
    shape : tuple of ints
        The elements of the shape tuple give the lengths of the
        corresponding array dimensions.
    
    See Also
    --------
    alen
    ndarray.shape : Equivalent array method.
    
    Examples
    --------
    &gt;&gt;&gt; np.shape(np.eye(3))
    (3, 3)
    &gt;&gt;&gt; np.shape([[1, 2]])
    (1, 2)
    &gt;&gt;&gt; np.shape([0])
    (1,)
    &gt;&gt;&gt; np.shape(0)
    ()
    
    &gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;i4&#39;)])
    &gt;&gt;&gt; np.shape(a)
    (2,)
    &gt;&gt;&gt; a.shape
    (2,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">a</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(15,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>numpy.ndarray
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;T&#39;,
 &#39;__abs__&#39;,
 &#39;__add__&#39;,
 &#39;__and__&#39;,
 &#39;__array__&#39;,
 &#39;__array_finalize__&#39;,
 &#39;__array_function__&#39;,
 &#39;__array_interface__&#39;,
 &#39;__array_prepare__&#39;,
 &#39;__array_priority__&#39;,
 &#39;__array_struct__&#39;,
 &#39;__array_ufunc__&#39;,
 &#39;__array_wrap__&#39;,
 &#39;__bool__&#39;,
 &#39;__class__&#39;,
 &#39;__complex__&#39;,
 &#39;__contains__&#39;,
 &#39;__copy__&#39;,
 &#39;__deepcopy__&#39;,
 &#39;__delattr__&#39;,
 &#39;__delitem__&#39;,
 &#39;__dir__&#39;,
 &#39;__divmod__&#39;,
 &#39;__doc__&#39;,
 &#39;__eq__&#39;,
 &#39;__float__&#39;,
 &#39;__floordiv__&#39;,
 &#39;__format__&#39;,
 &#39;__ge__&#39;,
 &#39;__getattribute__&#39;,
 &#39;__getitem__&#39;,
 &#39;__gt__&#39;,
 &#39;__hash__&#39;,
 &#39;__iadd__&#39;,
 &#39;__iand__&#39;,
 &#39;__ifloordiv__&#39;,
 &#39;__ilshift__&#39;,
 &#39;__imatmul__&#39;,
 &#39;__imod__&#39;,
 &#39;__imul__&#39;,
 &#39;__index__&#39;,
 &#39;__init__&#39;,
 &#39;__init_subclass__&#39;,
 &#39;__int__&#39;,
 &#39;__invert__&#39;,
 &#39;__ior__&#39;,
 &#39;__ipow__&#39;,
 &#39;__irshift__&#39;,
 &#39;__isub__&#39;,
 &#39;__iter__&#39;,
 &#39;__itruediv__&#39;,
 &#39;__ixor__&#39;,
 &#39;__le__&#39;,
 &#39;__len__&#39;,
 &#39;__lshift__&#39;,
 &#39;__lt__&#39;,
 &#39;__matmul__&#39;,
 &#39;__mod__&#39;,
 &#39;__mul__&#39;,
 &#39;__ne__&#39;,
 &#39;__neg__&#39;,
 &#39;__new__&#39;,
 &#39;__or__&#39;,
 &#39;__pos__&#39;,
 &#39;__pow__&#39;,
 &#39;__radd__&#39;,
 &#39;__rand__&#39;,
 &#39;__rdivmod__&#39;,
 &#39;__reduce__&#39;,
 &#39;__reduce_ex__&#39;,
 &#39;__repr__&#39;,
 &#39;__rfloordiv__&#39;,
 &#39;__rlshift__&#39;,
 &#39;__rmatmul__&#39;,
 &#39;__rmod__&#39;,
 &#39;__rmul__&#39;,
 &#39;__ror__&#39;,
 &#39;__rpow__&#39;,
 &#39;__rrshift__&#39;,
 &#39;__rshift__&#39;,
 &#39;__rsub__&#39;,
 &#39;__rtruediv__&#39;,
 &#39;__rxor__&#39;,
 &#39;__setattr__&#39;,
 &#39;__setitem__&#39;,
 &#39;__setstate__&#39;,
 &#39;__sizeof__&#39;,
 &#39;__str__&#39;,
 &#39;__sub__&#39;,
 &#39;__subclasshook__&#39;,
 &#39;__truediv__&#39;,
 &#39;__xor__&#39;,
 &#39;all&#39;,
 &#39;any&#39;,
 &#39;argmax&#39;,
 &#39;argmin&#39;,
 &#39;argpartition&#39;,
 &#39;argsort&#39;,
 &#39;astype&#39;,
 &#39;base&#39;,
 &#39;byteswap&#39;,
 &#39;choose&#39;,
 &#39;clip&#39;,
 &#39;compress&#39;,
 &#39;conj&#39;,
 &#39;conjugate&#39;,
 &#39;copy&#39;,
 &#39;ctypes&#39;,
 &#39;cumprod&#39;,
 &#39;cumsum&#39;,
 &#39;data&#39;,
 &#39;diagonal&#39;,
 &#39;dot&#39;,
 &#39;dtype&#39;,
 &#39;dump&#39;,
 &#39;dumps&#39;,
 &#39;fill&#39;,
 &#39;flags&#39;,
 &#39;flat&#39;,
 &#39;flatten&#39;,
 &#39;getfield&#39;,
 &#39;imag&#39;,
 &#39;item&#39;,
 &#39;itemset&#39;,
 &#39;itemsize&#39;,
 &#39;max&#39;,
 &#39;mean&#39;,
 &#39;min&#39;,
 &#39;nbytes&#39;,
 &#39;ndim&#39;,
 &#39;newbyteorder&#39;,
 &#39;nonzero&#39;,
 &#39;partition&#39;,
 &#39;prod&#39;,
 &#39;ptp&#39;,
 &#39;put&#39;,
 &#39;ravel&#39;,
 &#39;real&#39;,
 &#39;repeat&#39;,
 &#39;reshape&#39;,
 &#39;resize&#39;,
 &#39;round&#39;,
 &#39;searchsorted&#39;,
 &#39;setfield&#39;,
 &#39;setflags&#39;,
 &#39;shape&#39;,
 &#39;size&#39;,
 &#39;sort&#39;,
 &#39;squeeze&#39;,
 &#39;std&#39;,
 &#39;strides&#39;,
 &#39;sum&#39;,
 &#39;swapaxes&#39;,
 &#39;take&#39;,
 &#39;tobytes&#39;,
 &#39;tofile&#39;,
 &#39;tolist&#39;,
 &#39;tostring&#39;,
 &#39;trace&#39;,
 &#39;transpose&#39;,
 &#39;var&#39;,
 &#39;view&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on getset descriptor numpy.ndarray.shape:

shape
    Tuple of array dimensions.
    
    The shape property is usually used to get the current shape of an array,
    but may also be used to reshape the array in-place by assigning a tuple of
    array dimensions to it.  As with `numpy.reshape`, one of the new shape
    dimensions can be -1, in which case its value is inferred from the size of
    the array and the remaining dimensions. Reshaping an array in-place will
    fail if a copy is required.
    
    Examples
    --------
    &gt;&gt;&gt; x = np.array([1, 2, 3, 4])
    &gt;&gt;&gt; x.shape
    (4,)
    &gt;&gt;&gt; y = np.zeros((2, 3, 4))
    &gt;&gt;&gt; y.shape
    (2, 3, 4)
    &gt;&gt;&gt; y.shape = (3, 8)
    &gt;&gt;&gt; y
    array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
    &gt;&gt;&gt; y.shape = (3, 6)
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    ValueError: total size of new array must be unchanged
    &gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    AttributeError: Incompatible shape for in-place modification. Use
    `.reshape()` to make a copy with the desired shape.
    
    See Also
    --------
    numpy.reshape : similar function
    ndarray.reshape : similar method
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(15,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">reshape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on method_descriptor:

reshape(...)
    a.reshape(shape, order=&#39;C&#39;)
    
    Returns an array containing the same data with a new shape.
    
    Refer to `numpy.reshape` for full documentation.
    
    See Also
    --------
    numpy.reshape : equivalent function
    
    Notes
    -----
    Unlike the free function `numpy.reshape`, this method on `ndarray` allows
    the elements of the shape parameter to be passed in as separate arguments.
    For example, ``a.reshape(10, 11)`` is equivalent to
    ``a.reshape((10, 11))``.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on built-in function reshape:

reshape(...) method of numpy.ndarray instance
    a.reshape(shape, order=&#39;C&#39;)
    
    Returns an array containing the same data with a new shape.
    
    Refer to `numpy.reshape` for full documentation.
    
    See Also
    --------
    numpy.reshape : equivalent function
    
    Notes
    -----
    Unlike the free function `numpy.reshape`, this method on `ndarray` allows
    the elements of the shape parameter to be passed in as separate arguments.
    For example, ``a.reshape(10, 11)`` is equivalent to
    ``a.reshape((10, 11))``.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function reshape in module numpy:

reshape(a, newshape, order=&#39;C&#39;)
    Gives a new shape to an array without changing its data.
    
    Parameters
    ----------
    a : array_like
        Array to be reshaped.
    newshape : int or tuple of ints
        The new shape should be compatible with the original shape. If
        an integer, then the result will be a 1-D array of that length.
        One shape dimension can be -1. In this case, the value is
        inferred from the length of the array and remaining dimensions.
    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional
        Read the elements of `a` using this index order, and place the
        elements into the reshaped array using this index order.  &#39;C&#39;
        means to read / write the elements using C-like index order,
        with the last axis index changing fastest, back to the first
        axis index changing slowest. &#39;F&#39; means to read / write the
        elements using Fortran-like index order, with the first index
        changing fastest, and the last index changing slowest. Note that
        the &#39;C&#39; and &#39;F&#39; options take no account of the memory layout of
        the underlying array, and only refer to the order of indexing.
        &#39;A&#39; means to read / write the elements in Fortran-like index
        order if `a` is Fortran *contiguous* in memory, C-like order
        otherwise.
    
    Returns
    -------
    reshaped_array : ndarray
        This will be a new view object if possible; otherwise, it will
        be a copy.  Note there is no guarantee of the *memory layout* (C- or
        Fortran- contiguous) of the returned array.
    
    See Also
    --------
    ndarray.reshape : Equivalent method.
    
    Notes
    -----
    It is not always possible to change the shape of an array without
    copying the data. If you want an error to be raised when the data is copied,
    you should assign the new shape to the shape attribute of the array::
    
     &gt;&gt;&gt; a = np.zeros((10, 2))
    
     # A transpose makes the array non-contiguous
     &gt;&gt;&gt; b = a.T
    
     # Taking a view makes it possible to modify the shape without modifying
     # the initial object.
     &gt;&gt;&gt; c = b.view()
     &gt;&gt;&gt; c.shape = (20)
     Traceback (most recent call last):
        ...
     AttributeError: Incompatible shape for in-place modification. Use
     `.reshape()` to make a copy with the desired shape.
    
    The `order` keyword gives the index ordering both for *fetching* the values
    from `a`, and then *placing* the values into the output array.
    For example, let&#39;s say you have an array:
    
    &gt;&gt;&gt; a = np.arange(6).reshape((3, 2))
    &gt;&gt;&gt; a
    array([[0, 1],
           [2, 3],
           [4, 5]])
    
    You can think of reshaping as first raveling the array (using the given
    index order), then inserting the elements from the raveled array into the
    new array using the same kind of index ordering as was used for the
    raveling.
    
    &gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering
    array([[0, 1, 2],
           [3, 4, 5]])
    &gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
    array([[0, 1, 2],
           [3, 4, 5]])
    &gt;&gt;&gt; np.reshape(a, (2, 3), order=&#39;F&#39;) # Fortran-like index ordering
    array([[0, 4, 3],
           [2, 1, 5]])
    &gt;&gt;&gt; np.reshape(np.ravel(a, order=&#39;F&#39;), (2, 3), order=&#39;F&#39;)
    array([[0, 4, 3],
           [2, 1, 5]])
    
    Examples
    --------
    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
    &gt;&gt;&gt; np.reshape(a, 6)
    array([1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; np.reshape(a, 6, order=&#39;F&#39;)
    array([1, 4, 2, 5, 3, 6])
    
    &gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
    array([[1, 2],
           [3, 4],
           [5, 6]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
</pre></div>
</div>
</div>
</div>
<div class="section" id="arreglos">
<h2>Arreglos<a class="headerlink" href="#arreglos" title="Enlazar permanentemente con este título">¶</a></h2>
<p><img alt="Image" src="https://www.pythoninformer.com/img/numpy/2d-array.png" /> <img alt="Image" src="https://www.pythoninformer.com/img/numpy/3d-array-stack.png" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">a</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1. ,  5.5, 10. ])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]
(15,)
[[ 1.  2.  3.  4.  5.]
 [ 6.  7.  8.  9. 10.]
 [11. 12. 13. 14. 15.]]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3, 5)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17. 18.
 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30.]
(30,)
[[[ 1.  2.  3.  4.  5.]
  [ 6.  7.  8.  9. 10.]
  [11. 12. 13. 14. 15.]]

 [[16. 17. 18. 19. 20.]
  [21. 22. 23. 24. 25.]
  [26. 27. 28. 29. 30.]]]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, 3, 5)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">d</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, 3, 5)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]],

       [[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]]])
</pre></div>
</div>
</div>
</div>
<p><img alt="Image" src="https://media.geeksforgeeks.org/wp-content/uploads/Numpy1.jpg" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[[ 1.,  2.,  3.,  4.,  5.],
        [ 6.,  7.,  8.,  9., 10.],
        [11., 12., 13., 14., 15.]],

       [[16., 17., 18., 19., 20.],
        [21., 22., 23., 24., 25.],
        [26., 27., 28., 29., 30.]]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>23.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[[1., 2.],
        [3., 4.]],

       [[5., 6.],
        [7., 8.]]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]],[[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],[</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">]]])</span>
<span class="n">e</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[[1., 2.],
        [3., 4.]],

       [[5., 6.],
        [7., 8.]]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 5., 12.],
       [21., 32.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="nd">@e</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[19., 22.],
       [43., 50.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[19., 22.],
       [43., 50.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">multi_dot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function multi_dot in module numpy.linalg:

multi_dot(arrays, *, out=None)
    Compute the dot product of two or more arrays in a single function call,
    while automatically selecting the fastest evaluation order.
    
    `multi_dot` chains `numpy.dot` and uses optimal parenthesization
    of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
    this can speed up the multiplication a lot.
    
    If the first argument is 1-D it is treated as a row vector.
    If the last argument is 1-D it is treated as a column vector.
    The other arguments must be 2-D.
    
    Think of `multi_dot` as::
    
        def multi_dot(arrays): return functools.reduce(np.dot, arrays)
    
    
    Parameters
    ----------
    arrays : sequence of array_like
        If the first argument is 1-D it is treated as row vector.
        If the last argument is 1-D it is treated as column vector.
        The other arguments must be 2-D.
    out : ndarray, optional
        Output argument. This must have the exact kind that would be returned
        if it was not used. In particular, it must have the right type, must be
        C-contiguous, and its dtype must be the dtype that would be returned
        for `dot(a, b)`. This is a performance feature. Therefore, if these
        conditions are not met, an exception is raised, instead of attempting
        to be flexible.
    
        .. versionadded:: 1.19.0
    
    Returns
    -------
    output : ndarray
        Returns the dot product of the supplied arrays.
    
    See Also
    --------
    dot : dot multiplication with two arguments.
    
    References
    ----------
    
    .. [1] Cormen, &quot;Introduction to Algorithms&quot;, Chapter 15.2, p. 370-378
    .. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication
    
    Examples
    --------
    `multi_dot` allows you to write::
    
    &gt;&gt;&gt; from numpy.linalg import multi_dot
    &gt;&gt;&gt; # Prepare some data
    &gt;&gt;&gt; A = np.random.random((10000, 100))
    &gt;&gt;&gt; B = np.random.random((100, 1000))
    &gt;&gt;&gt; C = np.random.random((1000, 5))
    &gt;&gt;&gt; D = np.random.random((5, 333))
    &gt;&gt;&gt; # the actual dot multiplication
    &gt;&gt;&gt; _ = multi_dot([A, B, C, D])
    
    instead of::
    
    &gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)
    
    Notes
    -----
    The cost for a matrix multiplication can be calculated with the
    following function::
    
        def cost(A, B):
            return A.shape[0] * A.shape[1] * B.shape[1]
    
    Assume we have three matrices
    :math:`A_{10x100}, B_{100x5}, C_{5x50}`.
    
    The costs for the two different parenthesizations are as follows::
    
        cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
        cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">multi_dot</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[19., 22.],
       [43., 50.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.   5.5 10. ]
[[ 1.  2.  3.  4.  5.]
 [ 6.  7.  8.  9. 10.]
 [11. 12. 13. 14. 15.]]
[144.  160.5 177.  193.5 210. ]
(5,)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ap</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
<span class="n">ap</span><span class="o">.</span><span class="n">shape</span>
<span class="n">rp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">rp</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1.   5.5 10. ]]
[[144.  160.5 177.  193.5 210. ]]
(1, 5)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">at</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
<span class="n">at</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.   5.5 10. ]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3,)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">apt</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="n">apt</span><span class="p">)</span>
<span class="n">apt</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1. ]
 [ 5.5]
 [10. ]]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3, 1)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 1.   5.5 10. ]
[16.5 16.5 16.5]
(3,)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">apt</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">apt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1. ]
 [ 5.5]
 [10. ]]
[[16.5]
 [16.5]
 [16.5]]
(3, 1)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="ejemplo-econometria">
<h1>Ejemplo Econometría<a class="headerlink" href="#ejemplo-econometria" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Los datos del libro de Wooldridge se encuentran en la siguiente direccción <a class="reference external" href="https://github.com/spring-haru/wooldridge">enlace</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>pip install wooldridge # solo es necesario instalarlo una vez
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: wooldridge in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (0.4.2)
Requirement already satisfied: pandas in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (from wooldridge) (1.1.3)
Requirement already satisfied: pytz&gt;=2017.2 in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (from pandas-&gt;wooldridge) (2020.1)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: numpy&gt;=1.15.4 in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (from pandas-&gt;wooldridge) (1.19.2)
Requirement already satisfied: python-dateutil&gt;=2.7.3 in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (from pandas-&gt;wooldridge) (2.8.1)
Requirement already satisfied: six&gt;=1.5 in /Users/rafamtz/opt/anaconda3/lib/python3.8/site-packages (from python-dateutil&gt;=2.7.3-&gt;pandas-&gt;wooldridge) (1.15.0)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">wooldridge</span> <span class="k">as</span> <span class="nn">woo</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">woo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;__all__&#39;,
 &#39;__author__&#39;,
 &#39;__builtins__&#39;,
 &#39;__cached__&#39;,
 &#39;__copyright__&#39;,
 &#39;__doc__&#39;,
 &#39;__file__&#39;,
 &#39;__license__&#39;,
 &#39;__loader__&#39;,
 &#39;__name__&#39;,
 &#39;__package__&#39;,
 &#39;__path__&#39;,
 &#39;__spec__&#39;,
 &#39;__version__&#39;,
 &#39;abspath&#39;,
 &#39;data&#39;,
 &#39;dataWoo&#39;,
 &#39;get_path&#39;,
 &#39;join&#39;,
 &#39;load_data&#39;,
 &#39;lst&#39;,
 &#39;pd&#39;,
 &#39;split&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">woo</span><span class="o">.</span><span class="n">__author__</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;Tetsu Haruyama&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">woo</span><span class="o">.</span><span class="n">lst</span><span class="p">)</span> <span class="c1"># lista de conjunto de datos</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>No Python documentation found for &#39;J.M. Wooldridge (2016) Introductory Econometrics: A Modern Approach,\n  Cengage Learning, 6th edition.\n\n  401k       401ksubs    admnrev       affairs     airfare\n  alcohol    apple       approval      athlet1     athlet2\n  attend     audit       barium        beauty      benefits\n  beveridge  big9salary  bwght         bwght2      campus\n  card       catholic    cement        census2000  ceosal1\n  ceosal2    charity     consump       corn        countymurders\n  cps78_85   cps91       crime1        crime2      crime3\n  crime4     discrim     driving       earns       econmath\n  elem94_95  engin       expendshares  ezanders    ezunem\n  fair       fertil1     fertil2       fertil3     fish\n  fringe     gpa1        gpa2          gpa3        happiness\n  hprice1    hprice2     hprice3       hseinv      htv\n  infmrt     injury      intdef        intqrt      inven\n  jtrain     jtrain2     jtrain3       kielmc      lawsch85\n  loanapp    lowbrth     mathpnl       meap00_01   meap01\n  meap93     meapsingle  minwage       mlb1        mroz\n  murder     nbasal      nyse          okun        openness\n  pension    phillips    pntsprd       prison      prminwge\n  rdchem     rdtelec     recid         rental      return\n  saving     sleep75     slp75_81      smoke       traffic1\n  traffic2   twoyear     volat         vote1       vote2\n  voucher    wage1       wage2         wagepan     wageprc\n  wine&#39;.
Use help() to get the interactive help utility.
Use help(str) for help on the str class.
</pre></div>
</div>
</div>
</div>
<div class="section" id="regresion-simple">
<h2>Regresión Simple<a class="headerlink" href="#regresion-simple" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="math notranslate nohighlight">
\[y = \beta_0 +\beta_1 x + u\]</div>
<div class="math notranslate nohighlight">
\[\hat\beta_0 = \bar{y}-\hat\beta_1 \bar{x}\]</div>
<div class="math notranslate nohighlight">
\[\hat\beta_1= \frac{Cov(x,y)}{Var(x)}\]</div>
<div class="section" id="wooldridge-2016-ejemplo-2-3">
<h3>Wooldridge 2016, ejemplo-2-3<a class="headerlink" href="#wooldridge-2016-ejemplo-2-3" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ceosal1</span> <span class="o">=</span> <span class="n">woo</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;ceosal1&#39;</span><span class="p">)</span>
<span class="n">ceosal1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>salary</th>
      <th>pcsalary</th>
      <th>sales</th>
      <th>roe</th>
      <th>pcroe</th>
      <th>ros</th>
      <th>indus</th>
      <th>finance</th>
      <th>consprod</th>
      <th>utility</th>
      <th>lsalary</th>
      <th>lsales</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1095</td>
      <td>20</td>
      <td>27595.000000</td>
      <td>14.1</td>
      <td>106.400002</td>
      <td>191</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>6.998509</td>
      <td>10.225389</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1001</td>
      <td>32</td>
      <td>9958.000000</td>
      <td>10.9</td>
      <td>-30.600000</td>
      <td>13</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>6.908755</td>
      <td>9.206132</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1122</td>
      <td>9</td>
      <td>6125.899902</td>
      <td>23.5</td>
      <td>-16.299999</td>
      <td>14</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>7.022868</td>
      <td>8.720281</td>
    </tr>
    <tr>
      <th>3</th>
      <td>578</td>
      <td>-9</td>
      <td>16246.000000</td>
      <td>5.9</td>
      <td>-25.700001</td>
      <td>-21</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>6.359574</td>
      <td>9.695602</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1368</td>
      <td>7</td>
      <td>21783.199219</td>
      <td>13.8</td>
      <td>-3.000000</td>
      <td>56</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>7.221105</td>
      <td>9.988894</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>204</th>
      <td>930</td>
      <td>10</td>
      <td>1509.099976</td>
      <td>9.0</td>
      <td>20.500000</td>
      <td>131</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>6.835185</td>
      <td>7.319269</td>
    </tr>
    <tr>
      <th>205</th>
      <td>525</td>
      <td>3</td>
      <td>1097.099976</td>
      <td>15.5</td>
      <td>20.100000</td>
      <td>72</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>6.263398</td>
      <td>7.000426</td>
    </tr>
    <tr>
      <th>206</th>
      <td>658</td>
      <td>32</td>
      <td>4542.600098</td>
      <td>12.1</td>
      <td>-7.800000</td>
      <td>68</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>6.489205</td>
      <td>8.421255</td>
    </tr>
    <tr>
      <th>207</th>
      <td>555</td>
      <td>6</td>
      <td>2023.000000</td>
      <td>13.7</td>
      <td>-14.600000</td>
      <td>60</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>6.318968</td>
      <td>7.612337</td>
    </tr>
    <tr>
      <th>208</th>
      <td>626</td>
      <td>0</td>
      <td>1442.500000</td>
      <td>14.4</td>
      <td>-10.200000</td>
      <td>62</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>6.439351</td>
      <td>7.274133</td>
    </tr>
  </tbody>
</table>
<p>209 rows × 12 columns</p>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">ceosal1</span><span class="p">[</span><span class="s1">&#39;roe&#39;</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ceosal1</span><span class="p">[</span><span class="s1">&#39;salary&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.series.Series&#39;&gt; &lt;class &#39;pandas.core.series.Series&#39;&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[7.25649898e+01 1.34253840e+03]
 [1.34253840e+03 1.88333164e+06]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cov_xy</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">cov_xy</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1342.5383979609712
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">var_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">var_x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>72.21778886672104
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x_bar</span><span class="p">,</span><span class="n">y_bar</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17.18421050521175 1281.1196172248804
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">var_x</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># utilizamos la varianza correcta</span>
<span class="n">b1</span> <span class="o">=</span> <span class="n">cov_xy</span><span class="o">/</span><span class="n">var_x</span>
<span class="n">b0</span> <span class="o">=</span> <span class="n">y_bar</span> <span class="o">-</span> <span class="n">b1</span>  <span class="o">*</span> <span class="n">x_bar</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>963.1913364725579 18.501186345214922
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function var in module numpy:

var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)
    Compute the variance along the specified axis.
    
    Returns the variance of the array elements, a measure of the spread of a
    distribution.  The variance is computed for the flattened array by
    default, otherwise over the specified axis.
    
    Parameters
    ----------
    a : array_like
        Array containing numbers whose variance is desired.  If `a` is not an
        array, a conversion is attempted.
    axis : None or int or tuple of ints, optional
        Axis or axes along which the variance is computed.  The default is to
        compute the variance of the flattened array.
    
        .. versionadded:: 1.7.0
    
        If this is a tuple of ints, a variance is performed over multiple axes,
        instead of a single axis or all the axes as before.
    dtype : data-type, optional
        Type to use in computing the variance.  For arrays of integer type
        the default is `float64`; for arrays of float types it is the same as
        the array type.
    out : ndarray, optional
        Alternate output array in which to place the result.  It must have
        the same shape as the expected output, but the type is cast if
        necessary.
    ddof : int, optional
        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is
        ``N - ddof``, where ``N`` represents the number of elements. By
        default `ddof` is zero.
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left
        in the result as dimensions with size one. With this option,
        the result will broadcast correctly against the input array.
    
        If the default value is passed, then `keepdims` will not be
        passed through to the `var` method of sub-classes of
        `ndarray`, however any non-default value will be.  If the
        sub-class&#39; method does not implement `keepdims` any
        exceptions will be raised.
    
    Returns
    -------
    variance : ndarray, see dtype parameter above
        If ``out=None``, returns a new array containing the variance;
        otherwise, a reference to the output array is returned.
    
    See Also
    --------
    std, mean, nanmean, nanstd, nanvar
    ufuncs-output-type
    
    Notes
    -----
    The variance is the average of the squared deviations from the mean,
    i.e.,  ``var = mean(abs(x - x.mean())**2)``.
    
    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
    If, however, `ddof` is specified, the divisor ``N - ddof`` is used
    instead.  In standard statistical practice, ``ddof=1`` provides an
    unbiased estimator of the variance of a hypothetical infinite population.
    ``ddof=0`` provides a maximum likelihood estimate of the variance for
    normally distributed variables.
    
    Note that for complex numbers, the absolute value is taken before
    squaring, so that the result is always real and nonnegative.
    
    For floating-point input, the variance is computed using the same
    precision the input has.  Depending on the input data, this can cause
    the results to be inaccurate, especially for `float32` (see example
    below).  Specifying a higher-accuracy accumulator using the ``dtype``
    keyword can alleviate this issue.
    
    Examples
    --------
    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
    &gt;&gt;&gt; np.var(a)
    1.25
    &gt;&gt;&gt; np.var(a, axis=0)
    array([1.,  1.])
    &gt;&gt;&gt; np.var(a, axis=1)
    array([0.25,  0.25])
    
    In single precision, var() can be inaccurate:
    
    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
    &gt;&gt;&gt; a[0, :] = 1.0
    &gt;&gt;&gt; a[1, :] = 0.1
    &gt;&gt;&gt; np.var(a)
    0.20250003
    
    Computing the variance in float64 is more accurate:
    
    &gt;&gt;&gt; np.var(a, dtype=np.float64)
    0.20249999932944759 # may vary
    &gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2
    0.2025
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="modulo-statsmodels">
<h3>Módulo statsmodels<a class="headerlink" href="#modulo-statsmodels" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference external" href="https://www.statsmodels.org/stable/index.html">statsmodels</a> <em>es un módulo de Python que proporciona clases y funciones para la estimación de muchos modelos estadísticos diferentes, así como para realizar pruebas estadísticas y exploración de datos estadísticos. Hay disponible una lista extensa de estadísticas de resultados para cada estimador.</em></p>
<p><strong>Tarea moral: instalar statsmodels con conda</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span> <span class="c1"># submodulo que permite utilizar las sintaxis de R para regresiones</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reg_smf</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="n">formula</span> <span class="o">=</span> <span class="s1">&#39;salary ~ roe&#39;</span><span class="p">,</span>
              <span class="n">data</span> <span class="o">=</span> <span class="n">ceosal1</span>
             <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Lo anterior solo es configuración del estimador, esto es común en algunos módulos de Python, por ejemplo el módulo <a class="reference external" href="https://scikit-learn.org/stable/">scikit-learn</a> para Machine Learning, tiene esta misma idea</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">reg_smf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>statsmodels.regression.linear_model.OLS
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">reg_smf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;__class__&#39;,
 &#39;__delattr__&#39;,
 &#39;__dict__&#39;,
 &#39;__dir__&#39;,
 &#39;__doc__&#39;,
 &#39;__eq__&#39;,
 &#39;__format__&#39;,
 &#39;__ge__&#39;,
 &#39;__getattribute__&#39;,
 &#39;__gt__&#39;,
 &#39;__hash__&#39;,
 &#39;__init__&#39;,
 &#39;__init_subclass__&#39;,
 &#39;__le__&#39;,
 &#39;__lt__&#39;,
 &#39;__module__&#39;,
 &#39;__ne__&#39;,
 &#39;__new__&#39;,
 &#39;__reduce__&#39;,
 &#39;__reduce_ex__&#39;,
 &#39;__repr__&#39;,
 &#39;__setattr__&#39;,
 &#39;__sizeof__&#39;,
 &#39;__str__&#39;,
 &#39;__subclasshook__&#39;,
 &#39;__weakref__&#39;,
 &#39;_data_attr&#39;,
 &#39;_df_model&#39;,
 &#39;_df_resid&#39;,
 &#39;_fit_collinear&#39;,
 &#39;_fit_ridge&#39;,
 &#39;_fit_zeros&#39;,
 &#39;_formula_max_endog&#39;,
 &#39;_get_init_kwds&#39;,
 &#39;_handle_data&#39;,
 &#39;_init_keys&#39;,
 &#39;_setup_score_hess&#39;,
 &#39;_sqrt_lasso&#39;,
 &#39;data&#39;,
 &#39;df_model&#39;,
 &#39;df_resid&#39;,
 &#39;endog&#39;,
 &#39;endog_names&#39;,
 &#39;exog&#39;,
 &#39;exog_names&#39;,
 &#39;fit&#39;,
 &#39;fit_regularized&#39;,
 &#39;formula&#39;,
 &#39;from_formula&#39;,
 &#39;get_distribution&#39;,
 &#39;hessian&#39;,
 &#39;hessian_factor&#39;,
 &#39;information&#39;,
 &#39;initialize&#39;,
 &#39;k_constant&#39;,
 &#39;loglike&#39;,
 &#39;nobs&#39;,
 &#39;predict&#39;,
 &#39;rank&#39;,
 &#39;score&#39;,
 &#39;weights&#39;,
 &#39;wendog&#39;,
 &#39;wexog&#39;,
 &#39;whiten&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">reg_smf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on OLS in module statsmodels.regression.linear_model object:

class OLS(WLS)
 |  OLS(endog, exog=None, missing=&#39;none&#39;, hasconst=None, **kwargs)
 |  
 |  Ordinary Least Squares
 |  
 |  Parameters
 |  ----------
 |  endog : array_like
 |      A 1-d endogenous response variable. The dependent variable.
 |  exog : array_like
 |      A nobs x k array where `nobs` is the number of observations and `k`
 |      is the number of regressors. An intercept is not included by default
 |      and should be added by the user. See
 |      :func:`statsmodels.tools.add_constant`.
 |  missing : str
 |      Available options are &#39;none&#39;, &#39;drop&#39;, and &#39;raise&#39;. If &#39;none&#39;, no nan
 |      checking is done. If &#39;drop&#39;, any observations with nans are dropped.
 |      If &#39;raise&#39;, an error is raised. Default is &#39;none&#39;.
 |  hasconst : None or bool
 |      Indicates whether the RHS includes a user-supplied constant. If True,
 |      a constant is not checked for and k_constant is set to 1 and all
 |      result statistics are calculated as if a constant is present. If
 |      False, a constant is not checked for and k_constant is set to 0.
 |  **kwargs
 |      Extra arguments that are used to set model properties when using the
 |      formula interface.
 |  
 |  Attributes
 |  ----------
 |  weights : scalar
 |      Has an attribute weights = array(1.0) due to inheritance from WLS.
 |  
 |  See Also
 |  --------
 |  WLS : Fit a linear model using Weighted Least Squares.
 |  GLS : Fit a linear model using Generalized Least Squares.
 |  
 |  Notes
 |  -----
 |  No constant is added by the model unless you are using formulas.
 |  
 |  Examples
 |  --------
 |  &gt;&gt;&gt; import statsmodels.api as sm
 |  &gt;&gt;&gt; import numpy as np
 |  &gt;&gt;&gt; duncan_prestige = sm.datasets.get_rdataset(&quot;Duncan&quot;, &quot;carData&quot;)
 |  &gt;&gt;&gt; Y = duncan_prestige.data[&#39;income&#39;]
 |  &gt;&gt;&gt; X = duncan_prestige.data[&#39;education&#39;]
 |  &gt;&gt;&gt; X = sm.add_constant(X)
 |  &gt;&gt;&gt; model = sm.OLS(Y,X)
 |  &gt;&gt;&gt; results = model.fit()
 |  &gt;&gt;&gt; results.params
 |  const        10.603498
 |  education     0.594859
 |  dtype: float64
 |  
 |  &gt;&gt;&gt; results.tvalues
 |  const        2.039813
 |  education    6.892802
 |  dtype: float64
 |  
 |  &gt;&gt;&gt; print(results.t_test([1, 0]))
 |                               Test for Constraints
 |  ==============================================================================
 |                   coef    std err          t      P&gt;|t|      [0.025      0.975]
 |  ------------------------------------------------------------------------------
 |  c0            10.6035      5.198      2.040      0.048       0.120      21.087
 |  ==============================================================================
 |  
 |  &gt;&gt;&gt; print(results.f_test(np.identity(2)))
 |  &lt;F test: F=array([[159.63031026]]), p=1.2607168903696672e-20, df_denom=43, df_num=2&gt;
 |  
 |  Method resolution order:
 |      OLS
 |      WLS
 |      RegressionModel
 |      statsmodels.base.model.LikelihoodModel
 |      statsmodels.base.model.Model
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, endog, exog=None, missing=&#39;none&#39;, hasconst=None, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  fit_regularized(self, method=&#39;elastic_net&#39;, alpha=0.0, L1_wt=1.0, start_params=None, profile_scale=False, refit=False, **kwargs)
 |      Return a regularized fit to a linear regression model.
 |      
 |      Parameters
 |      ----------
 |      method : str
 |          Either &#39;elastic_net&#39; or &#39;sqrt_lasso&#39;.
 |      alpha : scalar or array_like
 |          The penalty weight.  If a scalar, the same penalty weight
 |          applies to all variables in the model.  If a vector, it
 |          must have the same length as `params`, and contains a
 |          penalty weight for each coefficient.
 |      L1_wt : scalar
 |          The fraction of the penalty given to the L1 penalty term.
 |          Must be between 0 and 1 (inclusive).  If 0, the fit is a
 |          ridge fit, if 1 it is a lasso fit.
 |      start_params : array_like
 |          Starting values for ``params``.
 |      profile_scale : bool
 |          If True the penalized fit is computed using the profile
 |          (concentrated) log-likelihood for the Gaussian model.
 |          Otherwise the fit uses the residual sum of squares.
 |      refit : bool
 |          If True, the model is refit using only the variables that
 |          have non-zero coefficients in the regularized fit.  The
 |          refitted model is not regularized.
 |      **kwargs
 |          Additional keyword arguments that contain information used when
 |          constructing a model using the formula interface.
 |      
 |      Returns
 |      -------
 |      statsmodels.base.elastic_net.RegularizedResults
 |          The regularized results.
 |      
 |      Notes
 |      -----
 |      The elastic net uses a combination of L1 and L2 penalties.
 |      The implementation closely follows the glmnet package in R.
 |      
 |      The function that is minimized is:
 |      
 |      .. math::
 |      
 |          0.5*RSS/n + alpha*((1-L1\_wt)*|params|_2^2/2 + L1\_wt*|params|_1)
 |      
 |      where RSS is the usual regression sum of squares, n is the
 |      sample size, and :math:`|*|_1` and :math:`|*|_2` are the L1 and L2
 |      norms.
 |      
 |      For WLS and GLS, the RSS is calculated using the whitened endog and
 |      exog data.
 |      
 |      Post-estimation results are based on the same data used to
 |      select variables, hence may be subject to overfitting biases.
 |      
 |      The elastic_net method uses the following keyword arguments:
 |      
 |      maxiter : int
 |          Maximum number of iterations
 |      cnvrg_tol : float
 |          Convergence threshold for line searches
 |      zero_tol : float
 |          Coefficients below this threshold are treated as zero.
 |      
 |      The square root lasso approach is a variation of the Lasso
 |      that is largely self-tuning (the optimal tuning parameter
 |      does not depend on the standard deviation of the regression
 |      errors).  If the errors are Gaussian, the tuning parameter
 |      can be taken to be
 |      
 |      alpha = 1.1 * np.sqrt(n) * norm.ppf(1 - 0.05 / (2 * p))
 |      
 |      where n is the sample size and p is the number of predictors.
 |      
 |      The square root lasso uses the following keyword arguments:
 |      
 |      zero_tol : float
 |          Coefficients below this threshold are treated as zero.
 |      
 |      The cvxopt module is required to estimate model using the square root
 |      lasso.
 |      
 |      References
 |      ----------
 |      .. [*] Friedman, Hastie, Tibshirani (2008).  Regularization paths for
 |         generalized linear models via coordinate descent.  Journal of
 |         Statistical Software 33(1), 1-22 Feb 2010.
 |      
 |      .. [*] A Belloni, V Chernozhukov, L Wang (2011).  Square-root Lasso:
 |         pivotal recovery of sparse signals via conic programming.
 |         Biometrika 98(4), 791-806. https://arxiv.org/pdf/1009.5689.pdf
 |  
 |  hessian(self, params, scale=None)
 |      Evaluate the Hessian function at a given point.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The parameter vector at which the Hessian is computed.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          The Hessian matrix.
 |  
 |  hessian_factor(self, params, scale=None, observed=True)
 |      Calculate the weights for the Hessian.
 |      
 |      Parameters
 |      ----------
 |      params : ndarray
 |          The parameter at which Hessian is evaluated.
 |      scale : None or float
 |          If scale is None, then the default scale will be calculated.
 |          Default scale is defined by `self.scaletype` and set in fit.
 |          If scale is not None, then it is used as a fixed scale.
 |      observed : bool
 |          If True, then the observed Hessian is returned. If false then the
 |          expected information matrix is returned.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          A 1d weight vector used in the calculation of the Hessian.
 |          The hessian is obtained by `(exog.T * hessian_factor).dot(exog)`.
 |  
 |  loglike(self, params, scale=None)
 |      The likelihood function for the OLS model.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The coefficients with which to estimate the log-likelihood.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      float
 |          The likelihood function evaluated at params.
 |  
 |  score(self, params, scale=None)
 |      Evaluate the score function at a given point.
 |      
 |      The score corresponds to the profile (concentrated)
 |      log-likelihood in which the scale parameter has been profiled
 |      out.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The parameter vector at which the score function is
 |          computed.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          The score vector.
 |  
 |  whiten(self, x)
 |      OLS model whitener does nothing.
 |      
 |      Parameters
 |      ----------
 |      x : array_like
 |          Data to be whitened.
 |      
 |      Returns
 |      -------
 |      array_like
 |          The input array unmodified.
 |      
 |      See Also
 |      --------
 |      OLS : Fit a linear model using Ordinary Least Squares.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from RegressionModel:
 |  
 |  fit(self, method=&#39;pinv&#39;, cov_type=&#39;nonrobust&#39;, cov_kwds=None, use_t=None, **kwargs)
 |      Full fit of the model.
 |      
 |      The results include an estimate of covariance matrix, (whitened)
 |      residuals and an estimate of scale.
 |      
 |      Parameters
 |      ----------
 |      method : str, optional
 |          Can be &quot;pinv&quot;, &quot;qr&quot;.  &quot;pinv&quot; uses the Moore-Penrose pseudoinverse
 |          to solve the least squares problem. &quot;qr&quot; uses the QR
 |          factorization.
 |      cov_type : str, optional
 |          See `regression.linear_model.RegressionResults` for a description
 |          of the available covariance estimators.
 |      cov_kwds : list or None, optional
 |          See `linear_model.RegressionResults.get_robustcov_results` for a
 |          description required keywords for alternative covariance
 |          estimators.
 |      use_t : bool, optional
 |          Flag indicating to use the Student&#39;s t distribution when computing
 |          p-values.  Default behavior depends on cov_type. See
 |          `linear_model.RegressionResults.get_robustcov_results` for
 |          implementation details.
 |      **kwargs
 |          Additional keyword arguments that contain information used when
 |          constructing a model using the formula interface.
 |      
 |      Returns
 |      -------
 |      RegressionResults
 |          The model estimation results.
 |      
 |      See Also
 |      --------
 |      RegressionResults
 |          The results container.
 |      RegressionResults.get_robustcov_results
 |          A method to change the covariance estimator used when fitting the
 |          model.
 |      
 |      Notes
 |      -----
 |      The fit method uses the pseudoinverse of the design/exogenous variables
 |      to solve the least squares minimization.
 |  
 |  get_distribution(self, params, scale, exog=None, dist_class=None)
 |      Construct a random number generator for the predictive distribution.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The model parameters (regression coefficients).
 |      scale : scalar
 |          The variance parameter.
 |      exog : array_like
 |          The predictor variable matrix.
 |      dist_class : class
 |          A random number generator class.  Must take &#39;loc&#39; and &#39;scale&#39;
 |          as arguments and return a random number generator implementing
 |          an ``rvs`` method for simulating random values. Defaults to normal.
 |      
 |      Returns
 |      -------
 |      gen
 |          Frozen random number generator object with mean and variance
 |          determined by the fitted linear model.  Use the ``rvs`` method
 |          to generate random values.
 |      
 |      Notes
 |      -----
 |      Due to the behavior of ``scipy.stats.distributions objects``,
 |      the returned random number generator must be called with
 |      ``gen.rvs(n)`` where ``n`` is the number of observations in
 |      the data set used to fit the model.  If any other value is
 |      used for ``n``, misleading results will be produced.
 |  
 |  initialize(self)
 |      Initialize model components.
 |  
 |  predict(self, params, exog=None)
 |      Return linear predicted values from a design matrix.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          Parameters of a linear model.
 |      exog : array_like, optional
 |          Design / exogenous data. Model exog is used if None.
 |      
 |      Returns
 |      -------
 |      array_like
 |          An array of fitted values.
 |      
 |      Notes
 |      -----
 |      If the model has not yet been fit, params is not optional.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from RegressionModel:
 |  
 |  df_model
 |      The model degree of freedom.
 |      
 |      The dof is defined as the rank of the regressor matrix minus 1 if a
 |      constant is included.
 |  
 |  df_resid
 |      The residual degree of freedom.
 |      
 |      The dof is defined as the number of observations minus the rank of
 |      the regressor matrix.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from statsmodels.base.model.LikelihoodModel:
 |  
 |  information(self, params)
 |      Fisher information matrix of model.
 |      
 |      Returns -1 * Hessian of the log-likelihood evaluated at params.
 |      
 |      Parameters
 |      ----------
 |      params : ndarray
 |          The model parameters.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from statsmodels.base.model.Model:
 |  
 |  from_formula(formula, data, subset=None, drop_cols=None, *args, **kwargs) from builtins.type
 |      Create a Model from a formula and dataframe.
 |      
 |      Parameters
 |      ----------
 |      formula : str or generic Formula object
 |          The formula specifying the model.
 |      data : array_like
 |          The data for the model. See Notes.
 |      subset : array_like
 |          An array-like object of booleans, integers, or index values that
 |          indicate the subset of df to use in the model. Assumes df is a
 |          `pandas.DataFrame`.
 |      drop_cols : array_like
 |          Columns to drop from the design matrix.  Cannot be used to
 |          drop terms involving categoricals.
 |      *args
 |          Additional positional argument that are passed to the model.
 |      **kwargs
 |          These are passed to the model with one exception. The
 |          ``eval_env`` keyword is passed to patsy. It can be either a
 |          :class:`patsy:patsy.EvalEnvironment` object or an integer
 |          indicating the depth of the namespace to use. For example, the
 |          default ``eval_env=0`` uses the calling namespace. If you wish
 |          to use a &quot;clean&quot; environment set ``eval_env=-1``.
 |      
 |      Returns
 |      -------
 |      model
 |          The model instance.
 |      
 |      Notes
 |      -----
 |      data must define __getitem__ with the keys in the formula terms
 |      args and kwargs are passed on to the model instantiation. E.g.,
 |      a numpy structured or rec array, a dictionary, or a pandas DataFrame.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from statsmodels.base.model.Model:
 |  
 |  endog_names
 |      Names of endogenous variables.
 |  
 |  exog_names
 |      Names of exogenous variables.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from statsmodels.base.model.Model:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">reg_smf</span><span class="o">.</span><span class="n">fit</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on RegressionResultsWrapper in module statsmodels.regression.linear_model object:

class RegressionResultsWrapper(statsmodels.base.wrapper.ResultsWrapper)
 |  RegressionResultsWrapper(results)
 |  
 |  Class which wraps a statsmodels estimation Results class and steps in to
 |  reattach metadata to results (if available)
 |  
 |  Method resolution order:
 |      RegressionResultsWrapper
 |      statsmodels.base.wrapper.ResultsWrapper
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  conf_int(self, alpha=0.05, cols=None)
 |      conf_int(self, alpha=0.05, cols=None)
 |      
 |      Compute the confidence interval of the fitted parameters.
 |      
 |      Parameters
 |      ----------
 |      alpha : float, optional
 |          The `alpha` level for the confidence interval. The default
 |          `alpha` = .05 returns a 95% confidence interval.
 |      cols : array_like, optional
 |          Columns to included in returned confidence intervals.
 |      
 |      Returns
 |      -------
 |      array_like
 |          The confidence intervals.
 |      
 |      Notes
 |      -----
 |      The confidence interval is based on Student&#39;s t-distribution.
 |  
 |  cov_params(self, r_matrix=None, column=None, scale=None, cov_p=None, other=None)
 |      cov_params(self, r_matrix=None, column=None, scale=None, cov_p=None, other=None)
 |      
 |      Compute the variance/covariance matrix.
 |      
 |      The variance/covariance matrix can be of a linear contrast of the
 |      estimated parameters or all params multiplied by scale which will
 |      usually be an estimate of sigma^2.  Scale is assumed to be a scalar.
 |      
 |      Parameters
 |      ----------
 |      r_matrix : array_like
 |          Can be 1d, or 2d.  Can be used alone or with other.
 |      column : array_like, optional
 |          Must be used on its own.  Can be 0d or 1d see below.
 |      scale : float, optional
 |          Can be specified or not.  Default is None, which means that
 |          the scale argument is taken from the model.
 |      cov_p : ndarray, optional
 |          The covariance of the parameters. If not provided, this value is
 |          read from `self.normalized_cov_params` or
 |          `self.cov_params_default`.
 |      other : array_like, optional
 |          Can be used when r_matrix is specified.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          The covariance matrix of the parameter estimates or of linear
 |          combination of parameter estimates. See Notes.
 |      
 |      Notes
 |      -----
 |      (The below are assumed to be in matrix notation.)
 |      
 |      If no argument is specified returns the covariance matrix of a model
 |      ``(scale)*(X.T X)^(-1)``
 |      
 |      If contrast is specified it pre and post-multiplies as follows
 |      ``(scale) * r_matrix (X.T X)^(-1) r_matrix.T``
 |      
 |      If contrast and other are specified returns
 |      ``(scale) * r_matrix (X.T X)^(-1) other.T``
 |      
 |      If column is specified returns
 |      ``(scale) * (X.T X)^(-1)[column,column]`` if column is 0d
 |      
 |      OR
 |      
 |      ``(scale) * (X.T X)^(-1)[column][:,column]`` if column is 1d
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from statsmodels.base.wrapper.ResultsWrapper:
 |  
 |  __dir__(self)
 |      Default dir() implementation.
 |  
 |  __getattribute__(self, attr)
 |      Return getattr(self, name).
 |  
 |  __getstate__(self)
 |  
 |  __init__(self, results)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __setstate__(self, dict_)
 |  
 |  save(self, fname, remove_data=False)
 |      Save a pickle of this instance.
 |      
 |      Parameters
 |      ----------
 |      fname : {str, handle}
 |          Either a filename or a valid file handle.
 |      remove_data : bool
 |          If False (default), then the instance is pickled without changes.
 |          If True, then all arrays with length nobs are set to None before
 |          pickling. See the remove_data method.
 |          In some cases not all arrays will be set to None.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from statsmodels.base.wrapper.ResultsWrapper:
 |  
 |  load(fname) from builtins.type
 |      Load a pickled results instance
 |      
 |      .. warning::
 |      
 |         Loading pickled models is not secure against erroneous or
 |         maliciously constructed data. Never unpickle data received from
 |         an untrusted or unauthenticated source.
 |      
 |      Parameters
 |      ----------
 |      fname : {str, handle}
 |          A string filename or a file handle.
 |      
 |      Returns
 |      -------
 |      Results
 |          The unpickled results instance.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from statsmodels.base.wrapper.ResultsWrapper:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">reg_smf</span><span class="o">.</span><span class="n">fit</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;HC0_se&#39;,
 &#39;HC1_se&#39;,
 &#39;HC2_se&#39;,
 &#39;HC3_se&#39;,
 &#39;_HCCM&#39;,
 &#39;__class__&#39;,
 &#39;__delattr__&#39;,
 &#39;__dict__&#39;,
 &#39;__dir__&#39;,
 &#39;__doc__&#39;,
 &#39;__eq__&#39;,
 &#39;__format__&#39;,
 &#39;__ge__&#39;,
 &#39;__getattribute__&#39;,
 &#39;__gt__&#39;,
 &#39;__hash__&#39;,
 &#39;__init__&#39;,
 &#39;__init_subclass__&#39;,
 &#39;__le__&#39;,
 &#39;__lt__&#39;,
 &#39;__module__&#39;,
 &#39;__ne__&#39;,
 &#39;__new__&#39;,
 &#39;__reduce__&#39;,
 &#39;__reduce_ex__&#39;,
 &#39;__repr__&#39;,
 &#39;__setattr__&#39;,
 &#39;__sizeof__&#39;,
 &#39;__str__&#39;,
 &#39;__subclasshook__&#39;,
 &#39;__weakref__&#39;,
 &#39;_abat_diagonal&#39;,
 &#39;_cache&#39;,
 &#39;_data_attr&#39;,
 &#39;_data_in_cache&#39;,
 &#39;_get_robustcov_results&#39;,
 &#39;_is_nested&#39;,
 &#39;_use_t&#39;,
 &#39;_wexog_singular_values&#39;,
 &#39;aic&#39;,
 &#39;bic&#39;,
 &#39;bse&#39;,
 &#39;centered_tss&#39;,
 &#39;compare_f_test&#39;,
 &#39;compare_lm_test&#39;,
 &#39;compare_lr_test&#39;,
 &#39;condition_number&#39;,
 &#39;conf_int&#39;,
 &#39;conf_int_el&#39;,
 &#39;cov_HC0&#39;,
 &#39;cov_HC1&#39;,
 &#39;cov_HC2&#39;,
 &#39;cov_HC3&#39;,
 &#39;cov_kwds&#39;,
 &#39;cov_params&#39;,
 &#39;cov_type&#39;,
 &#39;df_model&#39;,
 &#39;df_resid&#39;,
 &#39;eigenvals&#39;,
 &#39;el_test&#39;,
 &#39;ess&#39;,
 &#39;f_pvalue&#39;,
 &#39;f_test&#39;,
 &#39;fittedvalues&#39;,
 &#39;fvalue&#39;,
 &#39;get_influence&#39;,
 &#39;get_prediction&#39;,
 &#39;get_robustcov_results&#39;,
 &#39;initialize&#39;,
 &#39;k_constant&#39;,
 &#39;llf&#39;,
 &#39;load&#39;,
 &#39;model&#39;,
 &#39;mse_model&#39;,
 &#39;mse_resid&#39;,
 &#39;mse_total&#39;,
 &#39;nobs&#39;,
 &#39;normalized_cov_params&#39;,
 &#39;outlier_test&#39;,
 &#39;params&#39;,
 &#39;predict&#39;,
 &#39;pvalues&#39;,
 &#39;remove_data&#39;,
 &#39;resid&#39;,
 &#39;resid_pearson&#39;,
 &#39;rsquared&#39;,
 &#39;rsquared_adj&#39;,
 &#39;save&#39;,
 &#39;scale&#39;,
 &#39;ssr&#39;,
 &#39;summary&#39;,
 &#39;summary2&#39;,
 &#39;t_test&#39;,
 &#39;t_test_pairwise&#39;,
 &#39;tvalues&#39;,
 &#39;uncentered_tss&#39;,
 &#39;use_t&#39;,
 &#39;wald_test&#39;,
 &#39;wald_test_terms&#39;,
 &#39;wresid&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regresion</span> <span class="o">=</span> <span class="n">reg_smf</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="nb">type</span><span class="p">(</span><span class="n">regresion</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>statsmodels.regression.linear_model.RegressionResultsWrapper
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regresion</span><span class="o">.</span><span class="n">params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Intercept    963.191336
roe           18.501186
dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regresion</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><table class="simpletable">
<caption>OLS Regression Results</caption>
<tr>
  <th>Dep. Variable:</th>         <td>salary</td>      <th>  R-squared:         </th> <td>   0.013</td>
</tr>
<tr>
  <th>Model:</th>                   <td>OLS</td>       <th>  Adj. R-squared:    </th> <td>   0.008</td>
</tr>
<tr>
  <th>Method:</th>             <td>Least Squares</td>  <th>  F-statistic:       </th> <td>   2.767</td>
</tr>
<tr>
  <th>Date:</th>             <td>Fri, 14 May 2021</td> <th>  Prob (F-statistic):</th>  <td>0.0978</td> 
</tr>
<tr>
  <th>Time:</th>                 <td>08:49:05</td>     <th>  Log-Likelihood:    </th> <td> -1804.5</td>
</tr>
<tr>
  <th>No. Observations:</th>      <td>   209</td>      <th>  AIC:               </th> <td>   3613.</td>
</tr>
<tr>
  <th>Df Residuals:</th>          <td>   207</td>      <th>  BIC:               </th> <td>   3620.</td>
</tr>
<tr>
  <th>Df Model:</th>              <td>     1</td>      <th>                     </th>     <td> </td>   
</tr>
<tr>
  <th>Covariance Type:</th>      <td>nonrobust</td>    <th>                     </th>     <td> </td>   
</tr>
</table>
<table class="simpletable">
<tr>
      <td></td>         <th>coef</th>     <th>std err</th>      <th>t</th>      <th>P>|t|</th>  <th>[0.025</th>    <th>0.975]</th>  
</tr>
<tr>
  <th>Intercept</th> <td>  963.1913</td> <td>  213.240</td> <td>    4.517</td> <td> 0.000</td> <td>  542.790</td> <td> 1383.592</td>
</tr>
<tr>
  <th>roe</th>       <td>   18.5012</td> <td>   11.123</td> <td>    1.663</td> <td> 0.098</td> <td>   -3.428</td> <td>   40.431</td>
</tr>
</table>
<table class="simpletable">
<tr>
  <th>Omnibus:</th>       <td>311.096</td> <th>  Durbin-Watson:     </th> <td>   2.105</td> 
</tr>
<tr>
  <th>Prob(Omnibus):</th> <td> 0.000</td>  <th>  Jarque-Bera (JB):  </th> <td>31120.902</td>
</tr>
<tr>
  <th>Skew:</th>          <td> 6.915</td>  <th>  Prob(JB):          </th> <td>    0.00</td> 
</tr>
<tr>
  <th>Kurtosis:</th>      <td>61.158</td>  <th>  Cond. No.          </th> <td>    43.3</td> 
</tr>
</table><br/><br/>Notes:<br/>[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;roe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;salary&#39;</span><span class="p">,</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ceosal1</span><span class="p">,</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span>
        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ceosal1</span><span class="p">[</span><span class="s1">&#39;roe&#39;</span><span class="p">],</span>
         <span class="n">regresion</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">,</span>
         <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span>
         <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;salary&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;roe&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;mireg.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/numpy_67_0.png" src="../../_images/numpy_67_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span> <span class="c1"># importamos el submododulo pero este no tiene la sintasix R</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;BayesGaussMI&#39;,
 &#39;BinomialBayesMixedGLM&#39;,
 &#39;Factor&#39;,
 &#39;GEE&#39;,
 &#39;GLM&#39;,
 &#39;GLMGam&#39;,
 &#39;GLS&#39;,
 &#39;GLSAR&#39;,
 &#39;GeneralizedPoisson&#39;,
 &#39;Logit&#39;,
 &#39;MANOVA&#39;,
 &#39;MI&#39;,
 &#39;MICE&#39;,
 &#39;MICEData&#39;,
 &#39;MNLogit&#39;,
 &#39;MixedLM&#39;,
 &#39;NegativeBinomial&#39;,
 &#39;NegativeBinomialP&#39;,
 &#39;NominalGEE&#39;,
 &#39;OLS&#39;,
 &#39;OrdinalGEE&#39;,
 &#39;PCA&#39;,
 &#39;PHReg&#39;,
 &#39;Poisson&#39;,
 &#39;PoissonBayesMixedGLM&#39;,
 &#39;ProbPlot&#39;,
 &#39;Probit&#39;,
 &#39;QuantReg&#39;,
 &#39;RLM&#39;,
 &#39;RecursiveLS&#39;,
 &#39;SurvfuncRight&#39;,
 &#39;WLS&#39;,
 &#39;ZeroInflatedGeneralizedPoisson&#39;,
 &#39;ZeroInflatedNegativeBinomialP&#39;,
 &#39;ZeroInflatedPoisson&#39;,
 &#39;__builtins__&#39;,
 &#39;__cached__&#39;,
 &#39;__doc__&#39;,
 &#39;__file__&#39;,
 &#39;__loader__&#39;,
 &#39;__name__&#39;,
 &#39;__package__&#39;,
 &#39;__spec__&#39;,
 &#39;__version__&#39;,
 &#39;add_constant&#39;,
 &#39;categorical&#39;,
 &#39;cov_struct&#39;,
 &#39;datasets&#39;,
 &#39;distributions&#39;,
 &#39;duration&#39;,
 &#39;emplike&#39;,
 &#39;families&#39;,
 &#39;formula&#39;,
 &#39;gam&#39;,
 &#39;genmod&#39;,
 &#39;graphics&#39;,
 &#39;iolib&#39;,
 &#39;load&#39;,
 &#39;load_pickle&#39;,
 &#39;multivariate&#39;,
 &#39;nonparametric&#39;,
 &#39;os&#39;,
 &#39;qqline&#39;,
 &#39;qqplot&#39;,
 &#39;qqplot_2samples&#39;,
 &#39;regression&#39;,
 &#39;robust&#39;,
 &#39;show_versions&#39;,
 &#39;stats&#39;,
 &#39;test&#39;,
 &#39;tools&#39;,
 &#39;tsa&#39;,
 &#39;webdoc&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on class OLS in module statsmodels.regression.linear_model:

class OLS(WLS)
 |  OLS(endog, exog=None, missing=&#39;none&#39;, hasconst=None, **kwargs)
 |  
 |  Ordinary Least Squares
 |  
 |  Parameters
 |  ----------
 |  endog : array_like
 |      A 1-d endogenous response variable. The dependent variable.
 |  exog : array_like
 |      A nobs x k array where `nobs` is the number of observations and `k`
 |      is the number of regressors. An intercept is not included by default
 |      and should be added by the user. See
 |      :func:`statsmodels.tools.add_constant`.
 |  missing : str
 |      Available options are &#39;none&#39;, &#39;drop&#39;, and &#39;raise&#39;. If &#39;none&#39;, no nan
 |      checking is done. If &#39;drop&#39;, any observations with nans are dropped.
 |      If &#39;raise&#39;, an error is raised. Default is &#39;none&#39;.
 |  hasconst : None or bool
 |      Indicates whether the RHS includes a user-supplied constant. If True,
 |      a constant is not checked for and k_constant is set to 1 and all
 |      result statistics are calculated as if a constant is present. If
 |      False, a constant is not checked for and k_constant is set to 0.
 |  **kwargs
 |      Extra arguments that are used to set model properties when using the
 |      formula interface.
 |  
 |  Attributes
 |  ----------
 |  weights : scalar
 |      Has an attribute weights = array(1.0) due to inheritance from WLS.
 |  
 |  See Also
 |  --------
 |  WLS : Fit a linear model using Weighted Least Squares.
 |  GLS : Fit a linear model using Generalized Least Squares.
 |  
 |  Notes
 |  -----
 |  No constant is added by the model unless you are using formulas.
 |  
 |  Examples
 |  --------
 |  &gt;&gt;&gt; import statsmodels.api as sm
 |  &gt;&gt;&gt; import numpy as np
 |  &gt;&gt;&gt; duncan_prestige = sm.datasets.get_rdataset(&quot;Duncan&quot;, &quot;carData&quot;)
 |  &gt;&gt;&gt; Y = duncan_prestige.data[&#39;income&#39;]
 |  &gt;&gt;&gt; X = duncan_prestige.data[&#39;education&#39;]
 |  &gt;&gt;&gt; X = sm.add_constant(X)
 |  &gt;&gt;&gt; model = sm.OLS(Y,X)
 |  &gt;&gt;&gt; results = model.fit()
 |  &gt;&gt;&gt; results.params
 |  const        10.603498
 |  education     0.594859
 |  dtype: float64
 |  
 |  &gt;&gt;&gt; results.tvalues
 |  const        2.039813
 |  education    6.892802
 |  dtype: float64
 |  
 |  &gt;&gt;&gt; print(results.t_test([1, 0]))
 |                               Test for Constraints
 |  ==============================================================================
 |                   coef    std err          t      P&gt;|t|      [0.025      0.975]
 |  ------------------------------------------------------------------------------
 |  c0            10.6035      5.198      2.040      0.048       0.120      21.087
 |  ==============================================================================
 |  
 |  &gt;&gt;&gt; print(results.f_test(np.identity(2)))
 |  &lt;F test: F=array([[159.63031026]]), p=1.2607168903696672e-20, df_denom=43, df_num=2&gt;
 |  
 |  Method resolution order:
 |      OLS
 |      WLS
 |      RegressionModel
 |      statsmodels.base.model.LikelihoodModel
 |      statsmodels.base.model.Model
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, endog, exog=None, missing=&#39;none&#39;, hasconst=None, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  fit_regularized(self, method=&#39;elastic_net&#39;, alpha=0.0, L1_wt=1.0, start_params=None, profile_scale=False, refit=False, **kwargs)
 |      Return a regularized fit to a linear regression model.
 |      
 |      Parameters
 |      ----------
 |      method : str
 |          Either &#39;elastic_net&#39; or &#39;sqrt_lasso&#39;.
 |      alpha : scalar or array_like
 |          The penalty weight.  If a scalar, the same penalty weight
 |          applies to all variables in the model.  If a vector, it
 |          must have the same length as `params`, and contains a
 |          penalty weight for each coefficient.
 |      L1_wt : scalar
 |          The fraction of the penalty given to the L1 penalty term.
 |          Must be between 0 and 1 (inclusive).  If 0, the fit is a
 |          ridge fit, if 1 it is a lasso fit.
 |      start_params : array_like
 |          Starting values for ``params``.
 |      profile_scale : bool
 |          If True the penalized fit is computed using the profile
 |          (concentrated) log-likelihood for the Gaussian model.
 |          Otherwise the fit uses the residual sum of squares.
 |      refit : bool
 |          If True, the model is refit using only the variables that
 |          have non-zero coefficients in the regularized fit.  The
 |          refitted model is not regularized.
 |      **kwargs
 |          Additional keyword arguments that contain information used when
 |          constructing a model using the formula interface.
 |      
 |      Returns
 |      -------
 |      statsmodels.base.elastic_net.RegularizedResults
 |          The regularized results.
 |      
 |      Notes
 |      -----
 |      The elastic net uses a combination of L1 and L2 penalties.
 |      The implementation closely follows the glmnet package in R.
 |      
 |      The function that is minimized is:
 |      
 |      .. math::
 |      
 |          0.5*RSS/n + alpha*((1-L1\_wt)*|params|_2^2/2 + L1\_wt*|params|_1)
 |      
 |      where RSS is the usual regression sum of squares, n is the
 |      sample size, and :math:`|*|_1` and :math:`|*|_2` are the L1 and L2
 |      norms.
 |      
 |      For WLS and GLS, the RSS is calculated using the whitened endog and
 |      exog data.
 |      
 |      Post-estimation results are based on the same data used to
 |      select variables, hence may be subject to overfitting biases.
 |      
 |      The elastic_net method uses the following keyword arguments:
 |      
 |      maxiter : int
 |          Maximum number of iterations
 |      cnvrg_tol : float
 |          Convergence threshold for line searches
 |      zero_tol : float
 |          Coefficients below this threshold are treated as zero.
 |      
 |      The square root lasso approach is a variation of the Lasso
 |      that is largely self-tuning (the optimal tuning parameter
 |      does not depend on the standard deviation of the regression
 |      errors).  If the errors are Gaussian, the tuning parameter
 |      can be taken to be
 |      
 |      alpha = 1.1 * np.sqrt(n) * norm.ppf(1 - 0.05 / (2 * p))
 |      
 |      where n is the sample size and p is the number of predictors.
 |      
 |      The square root lasso uses the following keyword arguments:
 |      
 |      zero_tol : float
 |          Coefficients below this threshold are treated as zero.
 |      
 |      The cvxopt module is required to estimate model using the square root
 |      lasso.
 |      
 |      References
 |      ----------
 |      .. [*] Friedman, Hastie, Tibshirani (2008).  Regularization paths for
 |         generalized linear models via coordinate descent.  Journal of
 |         Statistical Software 33(1), 1-22 Feb 2010.
 |      
 |      .. [*] A Belloni, V Chernozhukov, L Wang (2011).  Square-root Lasso:
 |         pivotal recovery of sparse signals via conic programming.
 |         Biometrika 98(4), 791-806. https://arxiv.org/pdf/1009.5689.pdf
 |  
 |  hessian(self, params, scale=None)
 |      Evaluate the Hessian function at a given point.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The parameter vector at which the Hessian is computed.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          The Hessian matrix.
 |  
 |  hessian_factor(self, params, scale=None, observed=True)
 |      Calculate the weights for the Hessian.
 |      
 |      Parameters
 |      ----------
 |      params : ndarray
 |          The parameter at which Hessian is evaluated.
 |      scale : None or float
 |          If scale is None, then the default scale will be calculated.
 |          Default scale is defined by `self.scaletype` and set in fit.
 |          If scale is not None, then it is used as a fixed scale.
 |      observed : bool
 |          If True, then the observed Hessian is returned. If false then the
 |          expected information matrix is returned.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          A 1d weight vector used in the calculation of the Hessian.
 |          The hessian is obtained by `(exog.T * hessian_factor).dot(exog)`.
 |  
 |  loglike(self, params, scale=None)
 |      The likelihood function for the OLS model.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The coefficients with which to estimate the log-likelihood.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      float
 |          The likelihood function evaluated at params.
 |  
 |  score(self, params, scale=None)
 |      Evaluate the score function at a given point.
 |      
 |      The score corresponds to the profile (concentrated)
 |      log-likelihood in which the scale parameter has been profiled
 |      out.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The parameter vector at which the score function is
 |          computed.
 |      scale : float or None
 |          If None, return the profile (concentrated) log likelihood
 |          (profiled over the scale parameter), else return the
 |          log-likelihood using the given scale value.
 |      
 |      Returns
 |      -------
 |      ndarray
 |          The score vector.
 |  
 |  whiten(self, x)
 |      OLS model whitener does nothing.
 |      
 |      Parameters
 |      ----------
 |      x : array_like
 |          Data to be whitened.
 |      
 |      Returns
 |      -------
 |      array_like
 |          The input array unmodified.
 |      
 |      See Also
 |      --------
 |      OLS : Fit a linear model using Ordinary Least Squares.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from RegressionModel:
 |  
 |  fit(self, method=&#39;pinv&#39;, cov_type=&#39;nonrobust&#39;, cov_kwds=None, use_t=None, **kwargs)
 |      Full fit of the model.
 |      
 |      The results include an estimate of covariance matrix, (whitened)
 |      residuals and an estimate of scale.
 |      
 |      Parameters
 |      ----------
 |      method : str, optional
 |          Can be &quot;pinv&quot;, &quot;qr&quot;.  &quot;pinv&quot; uses the Moore-Penrose pseudoinverse
 |          to solve the least squares problem. &quot;qr&quot; uses the QR
 |          factorization.
 |      cov_type : str, optional
 |          See `regression.linear_model.RegressionResults` for a description
 |          of the available covariance estimators.
 |      cov_kwds : list or None, optional
 |          See `linear_model.RegressionResults.get_robustcov_results` for a
 |          description required keywords for alternative covariance
 |          estimators.
 |      use_t : bool, optional
 |          Flag indicating to use the Student&#39;s t distribution when computing
 |          p-values.  Default behavior depends on cov_type. See
 |          `linear_model.RegressionResults.get_robustcov_results` for
 |          implementation details.
 |      **kwargs
 |          Additional keyword arguments that contain information used when
 |          constructing a model using the formula interface.
 |      
 |      Returns
 |      -------
 |      RegressionResults
 |          The model estimation results.
 |      
 |      See Also
 |      --------
 |      RegressionResults
 |          The results container.
 |      RegressionResults.get_robustcov_results
 |          A method to change the covariance estimator used when fitting the
 |          model.
 |      
 |      Notes
 |      -----
 |      The fit method uses the pseudoinverse of the design/exogenous variables
 |      to solve the least squares minimization.
 |  
 |  get_distribution(self, params, scale, exog=None, dist_class=None)
 |      Construct a random number generator for the predictive distribution.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          The model parameters (regression coefficients).
 |      scale : scalar
 |          The variance parameter.
 |      exog : array_like
 |          The predictor variable matrix.
 |      dist_class : class
 |          A random number generator class.  Must take &#39;loc&#39; and &#39;scale&#39;
 |          as arguments and return a random number generator implementing
 |          an ``rvs`` method for simulating random values. Defaults to normal.
 |      
 |      Returns
 |      -------
 |      gen
 |          Frozen random number generator object with mean and variance
 |          determined by the fitted linear model.  Use the ``rvs`` method
 |          to generate random values.
 |      
 |      Notes
 |      -----
 |      Due to the behavior of ``scipy.stats.distributions objects``,
 |      the returned random number generator must be called with
 |      ``gen.rvs(n)`` where ``n`` is the number of observations in
 |      the data set used to fit the model.  If any other value is
 |      used for ``n``, misleading results will be produced.
 |  
 |  initialize(self)
 |      Initialize model components.
 |  
 |  predict(self, params, exog=None)
 |      Return linear predicted values from a design matrix.
 |      
 |      Parameters
 |      ----------
 |      params : array_like
 |          Parameters of a linear model.
 |      exog : array_like, optional
 |          Design / exogenous data. Model exog is used if None.
 |      
 |      Returns
 |      -------
 |      array_like
 |          An array of fitted values.
 |      
 |      Notes
 |      -----
 |      If the model has not yet been fit, params is not optional.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from RegressionModel:
 |  
 |  df_model
 |      The model degree of freedom.
 |      
 |      The dof is defined as the rank of the regressor matrix minus 1 if a
 |      constant is included.
 |  
 |  df_resid
 |      The residual degree of freedom.
 |      
 |      The dof is defined as the number of observations minus the rank of
 |      the regressor matrix.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from statsmodels.base.model.LikelihoodModel:
 |  
 |  information(self, params)
 |      Fisher information matrix of model.
 |      
 |      Returns -1 * Hessian of the log-likelihood evaluated at params.
 |      
 |      Parameters
 |      ----------
 |      params : ndarray
 |          The model parameters.
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from statsmodels.base.model.Model:
 |  
 |  from_formula(formula, data, subset=None, drop_cols=None, *args, **kwargs) from builtins.type
 |      Create a Model from a formula and dataframe.
 |      
 |      Parameters
 |      ----------
 |      formula : str or generic Formula object
 |          The formula specifying the model.
 |      data : array_like
 |          The data for the model. See Notes.
 |      subset : array_like
 |          An array-like object of booleans, integers, or index values that
 |          indicate the subset of df to use in the model. Assumes df is a
 |          `pandas.DataFrame`.
 |      drop_cols : array_like
 |          Columns to drop from the design matrix.  Cannot be used to
 |          drop terms involving categoricals.
 |      *args
 |          Additional positional argument that are passed to the model.
 |      **kwargs
 |          These are passed to the model with one exception. The
 |          ``eval_env`` keyword is passed to patsy. It can be either a
 |          :class:`patsy:patsy.EvalEnvironment` object or an integer
 |          indicating the depth of the namespace to use. For example, the
 |          default ``eval_env=0`` uses the calling namespace. If you wish
 |          to use a &quot;clean&quot; environment set ``eval_env=-1``.
 |      
 |      Returns
 |      -------
 |      model
 |          The model instance.
 |      
 |      Notes
 |      -----
 |      data must define __getitem__ with the keys in the formula terms
 |      args and kwargs are passed on to the model instantiation. E.g.,
 |      a numpy structured or rec array, a dictionary, or a pandas DataFrame.
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from statsmodels.base.model.Model:
 |  
 |  endog_names
 |      Names of endogenous variables.
 |  
 |  exog_names
 |      Names of exogenous variables.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from statsmodels.base.model.Model:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="n">ceosal1</span><span class="p">[</span><span class="s1">&#39;salary&#39;</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">ceosal1</span><span class="p">[</span><span class="s1">&#39;roe&#39;</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">reg_sm</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>       <span class="c1"># configuramos el estimador</span>
<span class="n">regresion_sm</span> <span class="o">=</span> <span class="n">reg_sm</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="n">regresion_sm</span><span class="o">.</span><span class="n">params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>const    963.191336
roe       18.501186
dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regresion_sm</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><table class="simpletable">
<caption>OLS Regression Results</caption>
<tr>
  <th>Dep. Variable:</th>         <td>salary</td>      <th>  R-squared:         </th> <td>   0.013</td>
</tr>
<tr>
  <th>Model:</th>                   <td>OLS</td>       <th>  Adj. R-squared:    </th> <td>   0.008</td>
</tr>
<tr>
  <th>Method:</th>             <td>Least Squares</td>  <th>  F-statistic:       </th> <td>   2.767</td>
</tr>
<tr>
  <th>Date:</th>             <td>Fri, 14 May 2021</td> <th>  Prob (F-statistic):</th>  <td>0.0978</td> 
</tr>
<tr>
  <th>Time:</th>                 <td>08:49:09</td>     <th>  Log-Likelihood:    </th> <td> -1804.5</td>
</tr>
<tr>
  <th>No. Observations:</th>      <td>   209</td>      <th>  AIC:               </th> <td>   3613.</td>
</tr>
<tr>
  <th>Df Residuals:</th>          <td>   207</td>      <th>  BIC:               </th> <td>   3620.</td>
</tr>
<tr>
  <th>Df Model:</th>              <td>     1</td>      <th>                     </th>     <td> </td>   
</tr>
<tr>
  <th>Covariance Type:</th>      <td>nonrobust</td>    <th>                     </th>     <td> </td>   
</tr>
</table>
<table class="simpletable">
<tr>
    <td></td>       <th>coef</th>     <th>std err</th>      <th>t</th>      <th>P>|t|</th>  <th>[0.025</th>    <th>0.975]</th>  
</tr>
<tr>
  <th>const</th> <td>  963.1913</td> <td>  213.240</td> <td>    4.517</td> <td> 0.000</td> <td>  542.790</td> <td> 1383.592</td>
</tr>
<tr>
  <th>roe</th>   <td>   18.5012</td> <td>   11.123</td> <td>    1.663</td> <td> 0.098</td> <td>   -3.428</td> <td>   40.431</td>
</tr>
</table>
<table class="simpletable">
<tr>
  <th>Omnibus:</th>       <td>311.096</td> <th>  Durbin-Watson:     </th> <td>   2.105</td> 
</tr>
<tr>
  <th>Prob(Omnibus):</th> <td> 0.000</td>  <th>  Jarque-Bera (JB):  </th> <td>31120.902</td>
</tr>
<tr>
  <th>Skew:</th>          <td> 6.915</td>  <th>  Prob(JB):          </th> <td>    0.00</td> 
</tr>
<tr>
  <th>Kurtosis:</th>      <td>61.158</td>  <th>  Cond. No.          </th> <td>    43.3</td> 
</tr>
</table><br/><br/>Notes:<br/>[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</div></div>
</div>
</div>
<div class="section" id="guardamos-las-regresiones">
<h3>Guardamos las regresiones<a class="headerlink" href="#guardamos-las-regresiones" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="n">archi_g</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;regsm.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">reg_sm</span><span class="p">,</span> <span class="n">archi_g</span><span class="p">)</span>
<span class="n">archi_g</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">archi_o</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;regsm.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">reg_sm</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">archi_o</span><span class="p">)</span>
<span class="n">archi_o</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reg_sm</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>const    963.191336
roe       18.501186
dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">archi_g</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;regsmf.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">reg_smf</span><span class="p">,</span> <span class="n">archi_g</span><span class="p">)</span>
<span class="n">archi_g</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "rafneta/CienciaDatosPythonCIDE",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Laboratorios/Lab8"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="lab8.html" title="previous page">Laboratorio 8</a>
    <a class='right-next' id="next-link" href="Pandas.html" title="next page">Pandas</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          Por Rafael Martínez-Martínez and Federico Daverio<br/>
        
            &copy; Derechos de autor .<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>